module type_check/tp_datatypes

imports
  signatures/start-sig
  type_check/beta_eq
  type_check/scopes
  type_check/type_check
  type_check/tp_fn
  
rules

  //---- Type of DataType
  // A datatype is a type
  typeOfExpr_(_, e@DataType(_, _, _, _)) = (e, Type()).
  
  // If we find a declaration
  typeOfExpr_(s, DataTypeDecl(n, ps, is, cs, b)) = (DataTypeDecl(n', ps', is', cs', b'), b_type) :- {s1 s2 s3a s3 s4}
  	scopeName(s2, n) == n',

	// Declare datatype
  	sPutType(s, n', createCoreType(Type(), ps', is')) == s1,
  	sPutDataTypeDecl(s1, n', DataType(n', ps', is', cs')) == s2,
  	
  	// Typecheck params in s, add their definitions to s2
  	dataTypeParams(s2, ps) == (s3, ps'),
  	dataTypeParams(s3, is) == (_, is'),
  	
  	// Add all constructors to s2 to create s4. Type check them in the context of s3.
  	dataTypeConstrs(n', s3, s2, cs, ps', is') == (s4, cs'),
  	
  	// Type check body in s4
  	typeOfExpr(s4, b) == (b', b_type).
  	
  // Creates the Expression `T -> e`, given params and indices
  createCoreType : Expr * list(DataParam) * list(DataParam) -> Expr
  createCoreType(c, [], []) = c.
  createCoreType(c, [Param(p, e) | ps], is) = FnType(p, e, createCoreType(c, ps, is)).
  createCoreType(c, [], [Param(p, e) | is]) = FnType(p, e, createCoreType(c, [], is)).
  	
  // scope to put def * params -> scope that def was put * checked params
  dataTypeParams : scope * list(DataParam) -> (scope * list(DataParam))
  dataTypeParams(s, []) = (s, []).
  dataTypeParams(s, [Param(n, e) | ps]) = (s'', [Param(n', e') | ps']) :- {s'}
  	scopeName(s, n) == n',
  	typeOfExpr(s, e) == (e', _),
  	sPutType(s, n', e') == s',
  	dataTypeParams(s', ps) == (s'', ps').
  
  	
  // We want to put all the constructors in the second scope, the first scope is the context to check the constructors in (constructors cannot see eachother)
  dataTypeConstrs : ID * scope * scope * list(DataConstructor) * list(DataParam) * list(DataParam) -> (scope * list(DataConstructor))
  dataTypeConstrs(_, _, s, [], _, _) = (s, []).
  dataTypeConstrs(dn, sb, s, [Constructor(n, e) | cs], ps, is) = (s'', [Constructor(n', e') | cs']) :- {s' e_type e''}
  	scopeName(s', n) == n',
  	
  	typeOfExpr(sb, e) == (e', e_type),
  	checkConstructor(e', dn, ps, is),
  	expectBetaEq((sEmpty(), e_type), (sEmpty(), Type())),
  	
  	createCoreType(e', ps, []) == e'',
  	sPutType(s, n', betaReduce((sb, e''))) == s',
  	dataTypeConstrs(dn, sb, s', cs, ps, is) == (s'', cs').
  	
  // Creates the expression `Maybe T1 T2..`
  createCoreElim : Expr * list(DataParam) * list(DataParam) -> Expr
  createCoreElim(c, [], []) = c.
  createCoreElim(c, [Param(p, _) | ps], is) = createCoreElim(FnDestruct(c, Var(p)), ps, is).
  createCoreElim(c, [], [Param(p, _) | is]) = createCoreElim(FnDestruct(c, Var(p)), [], is).
  
  	
  // Check if a specific constructor is strictly positive'
  // c = Core elim
  checkConstructor : Expr * ID * list(DataParam) * list(DataParam)
  // Core type checks
  checkConstructor(Var(n), n, [], []).
  // Match a param arg, this is must be exactly equal
  checkConstructor(FnDestruct(b, Var(m)), n, [Param(m, _) | ps], is) :- checkConstructor(b, n, ps, is).
  // Match a indexed arg, this can be anything
  checkConstructor(FnDestruct(b, _), n, [], [Param(_, _) | is]) :- checkConstructor(b, n, [], is).
  checkConstructor(FnType(_, v, b), n, ps, is) :- checkConstructorPos(v, n), checkConstructor(b, n, ps, is).
  
  // Check that an expression is strictly positive
  checkConstructorPos : Expr * ID
  checkConstructorPos(FnDestruct(e1, e2), n) :- checkConstructorPos(e1, n), checkConstructorPos(e2, n).
  checkConstructorPos(FnType(_, e1, e2), n) :- checkConstructorNeg(e1, n), checkConstructorNeg(e2, n).
  checkConstructorPos(Var(_), _).
  checkConstructorPos(Type(), _).
  checkConstructorPos(BoolType(), _).
  
  // Check that an expression does not contain ID
  checkConstructorNeg : Expr * ID
  checkConstructorNeg(Var(n), m) :- n != m.
  checkConstructorNeg(FnType(_, e1, e2), n) :- checkConstructorNeg(e1, n), checkConstructorNeg(e2, n).
  checkConstructorNeg(Type(), _).
  checkConstructorNeg(BoolType(), _).
   	
  // -- Type of DataElim
  // We need to generate the type of the eliminator
  // It is beta reduced since it may contain variables
  typeOfExpr_(s, DataElim(n)) = (DataElim(n'), betaReduce((s, e_final))) :- {ps is cs sp p c e_p e_ptype e_core e_constructors}
  	sGetDataTypeDecl(s, n) == DataType(n', ps, is, cs),
  	
  	// The general structure is:
  	// params -> P: (indices -> v: D indices -> Type) -> constructors -> indices -> v: N params indices -> P v
  	
  	// Create 		`N params indices` for future use
  	c == createCoreElim(Var(n'), ps, is),
  	
  	// Create 		indices -> v : N params indices -> P v
  	e_core == createCoreType(
  		FnType(Syn("v"), c, FnDestruct(Var(p), Var(Syn("v")))), 
  		[], is),
  		
  	// Create		constructors -> ...
  	e_constructors == dataTypeElimsGen(e_core, p, cs, n'),
  	
  	// Create 		P
  	e_ptype == createCoreType(
  		// N params elims -> Type
  		FnType(Syn("_"), c, Type()), 
  		[], is),
  	new sp, p == ScopedName(sp, "P"),
  	e_p == FnType(p, e_ptype, e_constructors),
  	
  	// Create		params -> ...
  	e_final == createCoreType(e_p, ps, []).
  	
  // rest of type, name of P function, list of data constructors left -> generate the constructors
  dataTypeElimsGen : Expr * ID * list(DataConstructor) * ID -> Expr
  // generate rest of function
  dataTypeElimsGen(d, p, [], _) = d.
  // generate the next constructor, using dataTypeElimsGenSub to find the constructor
  // C = args -> N pars indices
  // -----------------------------------------
  // args+inductions -> P (C pars indices args)
  dataTypeElimsGen(d, p, [Constructor(c, e) | cs], n) = FnType(Syn("_"), e2, dataTypeElimsGen(d, p, cs, n)) :- {e1}
  	// C pars indices
  	e1 == dataTypeElimsGenSub1(e, c),
  	e2 == dataTypeElimsGenSub2(e, e1, p, n).
  
  // Constructor expr * C
  // Generate the core expression, the `(C pars indices)`
  dataTypeElimsGenSub1 : Expr * ID -> Expr
  dataTypeElimsGenSub1(Var(_), c) = Var(c).
  dataTypeElimsGenSub1(FnDestruct(b, a), c) = FnDestruct(dataTypeElimsGenSub1(b, c), a).
  dataTypeElimsGenSub1(FnType(m, _, b), c) = dataTypeElimsGenSub1(b, c).
  
  // Constructor expr * Return of dataTypeElimsGenSub1 * P * N
  // Wrap with `A -> ...` and add `C a`
  dataTypeElimsGenSub2 : Expr * Expr * ID * ID -> Expr
  dataTypeElimsGenSub2(Var(_), r, p, _) = FnDestruct(Var(p), r).
  dataTypeElimsGenSub2(FnDestruct(_, _), r, p, _) = FnDestruct(Var(p), r).
  dataTypeElimsGenSub2(FnType(m, a, b), r, p, n) = dataTypeElimsGenSub2a(p, m, a, isRec(a, n), base) :-
  	base == dataTypeElimsGenSub2(b, FnDestruct(r, Var(m)), p, n).
  dataTypeElimsGenSub2a : ID * ID * Expr * int * Expr -> Expr
  dataTypeElimsGenSub2a(p, m, a, 0, b) = FnType(m, a, b).
  dataTypeElimsGenSub2a(p, m, a, 1, b) = FnType(m, a, FnType(Syn("_"), FnDestruct(Var(p), Var(m)), b)).
  isRec : Expr * ID -> int
  isRec(Var(n), n) = 1.
  isRec(FnDestruct(b, _), n) = isRec(b, n).
  isRec(_, _) = 0.
  
  
  // Try to match an argument of form `N a b c d...`
  
//  dataTypeElimsGenSub(FnType(m, a, b), c, n) = dataTypeElimsGenSub()
  
//  // core elim of datatype, name of P function, constructor expression, the expression that is being built (starting with the constructor name, applying arguments)
//  dataTypeElimsGenSub : Expr * ID * Expr * Expr -> Expr
//  // Sub is the return type. We want to generate `P (C ...)`
//  dataTypeElimsGenSub(d, p, d, base) = FnDestruct(Var(p), base).
//  // Sub is a FnType with a == n. We generate:
//  // m: a (= n) -> _: p m -> rest
//  dataTypeElimsGenSub(d, p, FnType(m, d, b), base) = 
//  	FnType(m, d, 
//  		FnType(Syn("_"), FnDestruct(Var(p), Var(m)),
//  			dataTypeElimsGenSub(d, p, b, FnDestruct(base, Var(m)))
//  		)
//  	).
//  // Sub is a FnType a != n. We generate:
//  // m: a -> rest
//  // We add `(base m)` to the rest
//  dataTypeElimsGenSub(d, p, FnType(m, a, b), base) = FnType(m, a, dataTypeElimsGenSub(d, p, b, FnDestruct(base, Var(m)))).
  
  // -- Beta reduction rules  
  betaReduceHead((s, e@DataElim(n)), as) = betaReduceHeadChoose((s, e), as, i, j) :- {ps cs v}
  	sGetDataTypeDecl(s, n) == DataType(n, ps, _, cs),
  	bhrDataSplitArgs(as, ps, cs, 0) == (i, _, _, v, _),
  	bhrCheckV(cs, v) == j.
  	
  bhrCheckV : list(DataConstructor) * (scope * Expr) -> int
  bhrCheckV([], (s, Var(n))) = 0.
  bhrCheckV([Constructor(n, _) | _], (s, Var(n))) = 1.
  bhrCheckV([Constructor(_, _) | cs], (s, Var(n))) = bhrCheckV(cs, (s, Var(n))).
  bhrCheckV(cs, (s, FnDestruct(f, _))) = bhrCheckV(cs, betaReduceHead((s, f), [])).
  	
  betaReduceHeadChoose : (scope * Expr) * list((scope * Expr)) * int * int -> (scope * Expr)
  betaReduceHeadChoose(e, as, _, _) = kRebuild(e, as).
  betaReduceHeadChoose((s, DataElim(n)), as, 1, 1) = betaReduceHead(brhDo(s, n, cs, a, (vn, v), [p | a], createCoreElim(Var(n), ps, [])), r) :- 
  	sGetDataTypeDecl(s, n) == DataType(n, ps, _, cs),
  	
  	bhrDataSplitArgs(as, ps, cs, 0) == (1, p, a, v, r),
  	brhDataCoreV(v) == vn.  
  
  // FINDS MATCHING CONSTRUCTOR
  // Given a
  // - Data type name
  // - Constructors of datatype
  // - Args applied to elimination
  // - Value that is elimininated, split up in original value and constructor name
  // - List of arguments to the original function, for recursive applications
  // Returns beta reduced value
  brhDo : scope * ID * list(DataConstructor) * list((scope * Expr)) * (ID * (scope * Expr)) * list((scope * Expr)) * Expr -> (scope * Expr)
  
  // Constructor matches, use brhDo2 on the result
  brhDo(s, n, [Constructor(c, ce) | cs], [a | as], (c, ve), ar, core) = brhDo2(s, n, ce, a, betaReduceHead(ve, []), ar, core).
  // Constructor does not match, skip
  brhDo(s, n, [Constructor(_, ce) | cs], [_ | as], (c, ve), ar, core) = brhDo(s, n, cs, as, (c, ve), ar, core).
  
  // APPLIES ARGUMENTS TO FUNCTION
  // Given a
  // - Data type name
  // - Constructor definition expression
  // - Function .. -> .. -> p (constructor) that was given to the eliminator for constructor
  // - Value that is elimininated
  // - List of arguments to the original function, for recursive applications
  // Returns beta reduced value
  // Ex 1: Bool Bool f _ 			=> f
  // Ex 2: Bool (.. -> c) f (vf va) => Bool c (f va) vf
  // Ex 3: Maybe (Maybe T) f _ 		=> f
  brhDo2 : scope * ID * Expr * (scope * Expr) * (scope * Expr) * list((scope * Expr)) * Expr -> (scope * Expr)
  brhDo2(s, n, core, f, _, _, core) = f.
  brhDo2(s, n, FnType(_, Var(n), c), f, (vs, FnDestruct(vf, va)), ar, core) = brhDo2(s, n, c, kApply(kApply(f, (vs, va)), r), betaReduceHead((vs, vf), []), ar, core) :-
  	r == betaReduceHead((s, DataElim(n)), append(ar, (vs, va))).
  brhDo2(s, n, FnType(_, _, c), f, (vs, FnDestruct(vf, va)), ar, core) = brhDo2(s, n, c, kApply(f, (vs, va)), betaReduceHead((vs, vf), []), ar, core).
  
 
  
  // Arguments look like PS P AS V R
  // Function returns P AS V R
  bhrDataSplitArgs : list((scope * Expr)) * list(DataParam) * list(DataConstructor) * int -> (int * (scope * Expr) * list((scope * Expr)) * (scope * Expr) * list((scope * Expr)))
  bhrDataSplitArgs([_|as], [_|ps], cs, 0) = bhrDataSplitArgs(as, ps, cs, 0). // skip ps arg
  bhrDataSplitArgs([p|as], [], cs, 0) = (r0, p, r1, r2, r3) :-                   // grab p arg
  	bhrDataSplitArgs(as, [], cs, 1) == (r0, _, r1, r2, r3).     
  bhrDataSplitArgs([a|as], [], [_|cs], 1) = (r0, _, [a|r1], r2, r3) :-           // grab a arg
  	bhrDataSplitArgs(as, [], cs, 1) == (r0, _, r1, r2, r3).
  bhrDataSplitArgs([v|rs], [], [], 1) = (1, _, [], betaReduceHead(v, []), rs).  // grab v arg
  bhrDataSplitArgs([], _, _, _) = (0, _, _, _, _). // no args left
  
  // Get the `v` argument from the `v` argument applied to things
  brhDataCoreV : (scope * Expr) -> ID
  brhDataCoreV((s, FnDestruct(f, a))) = brhDataCoreV(betaReduceHead((s, f), [])).
  brhDataCoreV((s, Var(n))) = n.
  
  append : list((scope * Expr)) * (scope * Expr) -> list((scope * Expr))
  append([], x) = [x].
  append([e | es], x) = [e | append(es, x)].
  
  betaReduce_((s, e@DataElim(_))) = e.
  
  
  
  