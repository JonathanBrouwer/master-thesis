\chapter{Term Inference}
\label{ch:inference}

Inference is an important feature of dependent programming languages, that allows redundant parts of programs to be left out. For example, it allows you to infer the arguments of a function, if they can be inferred by the arguments that follow, like here where the type of the argument can be inferred, since we pass it \verb|true| which is a boolean:
\begin{lstlisting}
let id = (\T : Type. \x: T. x);
id _ true
\end{lstlisting}

We call it \emph{term inference} rather than \emph{type inference}, because we can infer values other than types. For example, it can infer that the \verb|_| in this example must be \verb|true|:
\begin{lstlisting}
postulate f: Bool -> Type;
postulate g: f true -> Type;
\x: f _. g x
\end{lstlisting}

\section{Different algorithms for inference}
\label{strength-inference}

There are a lot of different algorithms for inference\cite{typeinference}, some algorithms can solve more inferences than others. One algorithm for unification is \emph{first-order unification} (FOU), where if at any point during type checking we assert that $\beq{e_1}{e_2}$ and either $e_1$ or $e_2$ is a free variable, we set the the value free variable to be equal to the value of the non-free variable. There are some situations in which this approach fails, but in most real-world scenarios it works perfectly. For example, it can infer both programs in the introduction of this chapter, but it fails to infer the following program:

\begin{lstlisting}
let f = _;
\x : Type.
\g: (_: (f x) -> Bool).
g true
\end{lstlisting}

We know that \verb|f| is a function from \verb|Type -> Type|, but it fails to infer the value of \verb|f|. Because of the way that \verb|g| is used, the type checker asserts that $\beq{f x}{Bool}$. Since x is declared as a function argument and it is completely free, this means that for any \verb|x|, \verb|f x = Bool|. But the rule above is not powerful enough to derive this, so it fails.

\section{Inference in Statix}
\label{statix-inference}

We would like to avoid implementing an algorithm at all, instead using Statix' built-in first-order unification to do the type inference for us. Implementing an inference algorithm in Statix is theoretically possible but this would be a lot of ugly code (since Statix is not a general-purpose programming language), and the goal is to use Statix in a way that is clean and declarative, not to do optimal inference.

However, we cannot immediately use Statix' built-in first-order unification (which acts in the meta language, Statix) to implement first-order unification in the object language. Ideally when implementing beta equality we would match on $\beq{e_1}{e_2}$ where $e_1$ is a free variable, but Statix does not allow for querying whether variables are free. 

Instead, we will be implementing a novel, less powerful form of first-order unification. This will work by explicitly denoting which variables \emph{could be} free, and explicitly handling these cases in a way that approximates first-order unification. We will denote this algorithm as \emph{approximated first-order unification (AFOU)}.

\section{Implementing AFOU}
\label{implementing-inference}

First, we introduce a new constructor \verb|Infer : Expr -> Expr|, which denotes the variables which could be free. The constructor is introduced when we encounter a \verb|_| variable, a marker that something needs to be inferred.
\begin{lstlisting}
typeOfExpr(s, Var(Syn("_"))) = (Infer(q), qt) :-
	(_, qt) == typeOfExpr(sEmpty(), q).
\end{lstlisting}

Note that the type of \verb|typeOfExpr| has changed, it now returns two expressions, the first being the same expression that was passed in except with \verb|_| variables replaced with \verb|Infer| constructors, and the second being the type.
\begin{lstlisting}
typeOfExpr : scope * Expr -> Expr * Expr
\end{lstlisting}

Next when we type-check an \verb|Infer| expression we just type-check the meta-variable inside. This will wait until the value of the meta-variable is known before type-checking, which is the behavior we want.
\begin{lstlisting}
typeOfExpr_(s, Infer(q)) = (Infer(q), t) :-
	typeOfExpr_(s, q) == (_, t).
\end{lstlisting}

When beta reducing we deliberately keep the \verb|Infer| expression intact, since we want to keep the information that it is an expression that might have to be inferred during beta equality checks.
\begin{lstlisting}
betaReduce_((_, Infer(e))) = Infer(e).
\end{lstlisting}

Finally, the difficult part of handling inference in beta equality. There are four different cases that involve \verb|Infer| expressions in beta equality, these are:

\begin{enumerate}
	\item A value \verb|e1| on the left, an infer expression on the right. In this case we simply want to set the metavariable equal to \verb|e1|. For example:
	\begin{lstlisting}
expectBetaEq((s1, e1@Type(_)), (_, Infer(e2))) :- e1 == e2.
expectBetaEq((s1, e1@BoolTrue()), (_, Infer(e2))) :- e1 == e2.
expectBetaEq((s1, e1@BoolFalse()), (_, Infer(e2))) :- e1 == e2.
expectBetaEq((s1, e1@BoolType()), (_, Infer(e2))) :- e1 == e2.
	\end{lstlisting}

	\item A complex expression \verb|e1| on the left, an infer expression on the right. In this case, we know what top-level constructor of the metavariable should be, but not necessarily the entire constructor (there might be infers in \verb|e1|). We introduce new \verb|Infer| expressions on the left, and call \verb|expectBetaEq| recursively. A simple example for \verb|BoolIf| is below:
	\begin{lstlisting}
expectBetaEq((s1, e1@BoolIf(c1, t1, b1)), (_, Infer(e2))) :-
	{c2 t2 b2}
	e2 == BoolIf(Infer(c2), Infer(t2), Infer(b2)),
	expectBetaEq((s1, e1), (sEmpty(), e2)).
	\end{lstlisting}
	\verb|FnType| and \verb|FnConstruct| work similarly, 
	
	\item An infer expression on the left, any expression on the right. We should not duplicate the previous two rules, instead, we can just swap the two expressions and re-use the rules above.
\begin{lstlisting}
expectBetaEq((_, Infer(e1)), (s2, e2)) :-
	expectBetaEq((s2, e2), (_, Infer(e1))).
\end{lstlisting}

	\item \label{inf-case4} An infer expression on both sides. This is where the approximation comes in. In normal first-order unification, we would see if either side is known, and possible apply one of the rules above depending on the result. This is not possible, so we're going to do something that approximates first-order unification: just set both sides to be equal. This is an approximation because this might fail if both sides are equal under beta equality but not identical. This approximation is analyzed in section \ref{analysing-inference}.
\begin{lstlisting}
expectBetaEq((_, Infer(e1)), (_, Infer(e2))) :-
	e1 == e2.
\end{lstlisting}
	
\end{enumerate}

\section{Analysis of the approximation}
\label{analysing-inference}

The only difference between AFOU and FOU is case \ref{inf-case4}. Instead of asserting that both sides are equal under beta equality, we assert that both sides are identical. Both sides being identical implies that they are beta-equal, so this approximation is sound, meaning there is no program that AFOU can infer but FOU cannot. 

The approximation is not complete: There are situations where AFOU fails to infer a program that FOU can infer. However, these programs are rare. This happens when a program contains multiple infer points, two of these are asserted to be beta-equal, and they are not identical but they are beta-equal. \todo{Find program where this fails.}

\section{Analysis of the implementation}
\label{analysing-inference-impl}

This process of defining a rule for each constructor in the language is a bit tedious, and it easy to accidentally get wrong. Stratego (the transformation language of Spoofax) allows for \emph{generic term deconstruction} \cite{generictermdestr}, if Statix would also have this feature this would make writing the rules above in a generic way possible. Borrowing some of the syntax from Stratego, this would look like this:

\begin{lstlisting}
expectBetaEq((s1, e1@c#(xs)), (_, Infer(e2))) :-
	e2 == c#(<all(Infer)>(xs)),
	expectBetaEq((s1, e1), (sEmpty(), e2)).
\end{lstlisting}



