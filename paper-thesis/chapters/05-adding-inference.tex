\chapter{Inference}

\section{Background: What is inference?}

Inference 

\section{General inference in Statix}
\label{general-inference}

\section{Greedy inference}

Instead, we implement a strategy that I would like to call greedy inference (TODO: does this have a name?). 

\section{Using Statix's first-order unification for inference}

First, we introduce a new constructor, \verb|Infer : Expr -> Expr|. This will be used to store metavariables which we want to infer. This is a hack we use, ideally we would like to query statix to see if a metavariable is initialized, but as discussed in section \ref{general-inference} this is not possible. 

The constructor is introduced when we encounter a \verb|_| variable, a sign that something needs to be inferred. When type-checking this, we create an infer constructor. The constraint at the bottom cannot be solved immediately, since the \verb|q| variable is unbound, but if \verb|q| is bound later the constraint will be evaluated.

\begin{lstlisting}
typeOfExpr_(s, Var(Syn("_"))) = (Infer(q), qt) :-
	(_, qt) == typeOfExpr(sEmpty(), q).
\end{lstlisting}
When an \verb|Infer| needs to be type-checked, the logic is very similar, except that we don't need to generate a new metavariable:

\begin{lstlisting}
typeOfExpr_(s, Infer(q)) = (Infer(q), t) :-
	typeOfExpr_(s, q) == (_, t).
\end{lstlisting}
When we encounter a \verb|Infer| in \verb|betaReduceHead|, we keep it intact, because we still want to know that it is a \verb|Infer| in the \verb|expectBetaEq| rule. 

The \verb|expectBetaEq| is where it gets interesting. We have a rule for each constructor in the language. For simple cases like \verb|BoolTrue|, we assert that \verb|e2| must be equal.
\begin{lstlisting}
expectBetaEq_((s1, e1@BoolTrue()), (_, Infer(e2))) :- e1 == e2.
\end{lstlisting}
For more complicated constructors such as \verb|FnType|, we generate new metavariables for the subexpressions, and assert they it must be beta-equal to the provided ones:
\begin{lstlisting}
expectBetaEq_(
	(s1, e1@FnType(arg_name1, arg_type1, body1)), 
	(_, Infer(e2))) :- {arg_type2 body2}
  e2 == FnType(arg_name1, Infer(arg_type2), Infer(body2)),
  expectBetaEq_((s1, e1), (sEmpty(), e2)).
\end{lstlisting}

Finally, there is a case for if we encounter two \verb|Infer|s. Ideally, we would look at whether one infer is instantiated, and apply the rules above. However, this is not possible since we cannot do such queries in Statix. Instead, we say that they must be exactly equal and we hope for the best. There are situations where this rule fails (where e1 and e2 are beta-equal but not identical), but this works well enough for practical use.
\begin{lstlisting}
expectBetaEq_((_, Infer(e1)), (_, Infer(e2))) :-
    e1 == e2.
\end{lstlisting}

\section{Analysis: How well does it work?}