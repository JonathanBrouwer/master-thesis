module main

imports

  statixruntime
  statix/api
  injections/-
  signatures/-
  pp
  completion
  strategolib
  libstratego-gpp
  libspoofax/sdf/pp
  
signature constructors
  Infer : Expr -> Expr

rules // Analysis

  pre-analyze  = id
  post-analyze = id
  
  pre-analyze  = explicate-injections-lody
  post-analyze = implicate-injections-lody

  editor-analyze = stx-editor-analyze(pre-analyze, post-analyze|"main", "programOk")
  editor-resolve = stx-editor-resolve
  
  editor-hover : x -> <conc-strings> (<stx-editor-hover> x, " --- ", <stx-editor-hover(|"Inferred") <+ !""> x)
  
//  get-type :: Expr -> Expr
  get-type : expr -> type' // Defines a rule which matches on node and returns type'
    with <debug(!"CHECKING: ")> expr
    where
      // Assigns variable a to be the result of the Statix analysis of the entire program (or throws an error)
      a := <stx-get-ast-analysis <+ fail-msg(|$[no analysis on node [<strip-annos;write-to-string> expr]])>;
      // Gets the type of the given node (or throws an error)
      type := <stx-get-ast-type(|a) <+ fail-msg(|$[no type on node [<strip-annos;write-to-string> expr]])> expr;
      
      type' := <uniquify> <strip-annos> type
//      type'' := <uniquify> (type', [])
      
  fail-msg(|msg) = err-msg(|$[get-type: [msg]]); fail
  
  // Defined for semantic code completion
  downgrade-placeholders = downgrade-placeholders-lody
  upgrade-placeholders   = upgrade-placeholders-lody
  is-inj                 = is-lody-inj-cons
  pp-partial             = pp-partial-lody-string  

//  remove-syns-sub : Syn(n) -> n
//  remove-syns-sub : x -> x
//  remove-syns = bottomup(try(remove-syns-sub))
  
  
  uniquify-sub :: ? -> ?
  uniquify-sub : s -> s'
  where <is(ID)> s
  where not(<Rename> s)
  with <gen-name> s => s'
  with rules( Rename : s -> s' )
  
  uniquify-sub : s -> s''
  where <is(ID)> s
  where <Rename> s => s''
  
  uniquify-sub : Infer(e) -> e
  
  uniquify :: ? -> ?
  uniquify = topdown(try(uniquify-sub))
  
  gen-name :: ID -> string
  gen-name : Syn(s) -> <gen-name-s> s
  
  gen-name-s :: string -> string
  gen-name-s : "_" -> "_"
  gen-name-s : s -> s
  where not(<RenameTaken> <strip-annos> s)
  with rules( RenameTaken : <strip-annos> s -> s )
  gen-name-s : s -> <gen-name-s> s'
  where <RenameTaken> <strip-annos> s
  with <conc-strings> (s, "'") => s'



  
  
