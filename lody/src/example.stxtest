resolve {s if a b c d e f sf fn_arg_name arg_type fn_type}
  new s,
//  typeOfExpr(s, 
//  	Let("f", 
//  		FnConstruct("x", Infer(if), BoolTrue()),
//  		FnDestruct(Var("f"), BoolTrue())
//  	)
//  ) == (_, _)

//  typeOfExpr_(s, Let(n, v, b)) = (Let(n, v', b'), b_type) :-
//  	typeOfExpr(s, v) == (v', _),
//  	typeOfExpr(scopePutSubst(s, n, (s, v')), b) == (b', b_type).


//  typeOfExpr_(s, q@Var(id)) = (q, typeOfNameEntry(scopeGetName(s, id))).
//  
//  typeOfNameEntry : NameEntry -> Expr
//  typeOfNameEntry(NameType(T)) = T.
//  typeOfNameEntry(NameSubst(se, e)) = t :- typeOfExpr(se, e) == (_, t).

  // Unfold let
  typeOfExpr(s, FnConstruct("x", Infer(if), BoolTrue())) == (a, _),
  b == scopePutSubst(s, "f", (s, a)),
  
  scopeGetName(b, "f") == NameSubst(c, d),
  typeOfExpr(c, d) == (e, f),
  f == fn_type,
  typeOfExpr(b, Var("f")) == (_, fn_type),
  
  
  
  fn_type == FnType("x", Infer(BoolType()), BoolType())
  

//  typeOfExpr(b, FnDestruct(Var("f"), BoolTrue())) == (_, c)
  
  
  
  
  
  
  // let f = (\x: _. true);
  // f true
imports
  signatures/start-sig
  type_check/beta_eq
  type_check/scopes
  type_check/do_lazy_substs
  type_check/type_check
  
  