\chapter{A comparison with implementations in logical frameworks}
\label{ch:comp-lambdapi}

In chapter \ref{ch:inference} we discussed how to implement inference algorithms, and we concluded in section \ref{analysing-inference} that adding equational unification to Statix would make inference algorithms easier to implement. In this chapter we explore this further, by implementing our dependently typed language in a logical framework. 

A logical framework is a language that provides a means to define a type system. There exist several \emph{logical frameworks}, designed specifically for implementing and experimenting with dependent type theories, such as ALF~\cite{MagnussonN93}, Twelf~\cite{PfenningS99}, Dedukti~\cite{BoespflugCH12}, Elf~\cite{pfenning_1991} and Andromeda~\cite{BauerHP20}. Since these tools are designed specifically for the task, implementing the type system takes less effort in them compared to Spoofax, but for other tasks such as defining a parser or editor services they are not as well equipped. 

In this chapter we will be implementing the language defined in chapter~\ref{chap:baselang} in lambdapi, a proof assistant based on the $\lambda \Pi$-calculus modulo rewriting~\cite{BoespflugCH12}. 

\section{Defining Symbols}

We will define a symbol in the meta language (lambdapi) for each construct in the object language. The result is visible in figure \ref{fig:lp-symbols}. We will leave \verb|Let| out of the language for now, it will be discussed separately in section \ref{ch:comp-lambdapi:let}.

\begin{figure}[ht]
\begin{lstlisting}
constant symbol TmSort : TYPE;
symbol TmType : `Π` (a : TmSort), TYPE;

constant symbol Type : TmSort;

constant symbol FnType :
  `Π` (A : TmSort), 
  `Π` (B : TmType A → TmSort), 
TmSort;

symbol FnConstruct :
  `Π` (A : TmSort), 
  `Π` (B : TmType A → TmSort), 
  `Π` (f : `Π` (x : TmType A), TmType (B x)), 
  TmType (FnType A B);

symbol FnDestruct :
  `Π` (A : TmSort), 
  `Π` (B : TmType A → TmSort), 
  `Π` (f : TmType (FnType A B)),
  `Π` (a : TmType A),
  TmType (B a);
\end{lstlisting}
	\caption{Symbols of the Calculus of Constructions}
\label{fig:lp-symbols}
\end{figure}

First, \verb|TmSort : TYPE| is the meta-language type of a type in the object language. So in any place where we say \verb|A : TmSort|, this means \verb|A| is a type in the object language. Next, \verb|TmType : (a : TmSort) -> TYPE| is the meta-language type of a term of type \verb|a| in the object language. So if we have \verb|x : TmType Bool| then \verb|x| is a boolean in the object language. 

Now we will define a symbol for each construct in the language we are defining.
\begin{enumerate}
	\item \verb|Type| is a type.
	\item \verb|FnType| is a type, but it takes two arguments: \verb|A| is the argument type and \verb|B| is the return type, which is allowed to depend on a value of the argument type.
	\item \verb|FnConstruct| takes three arguments: \verb|A| is the argument type, \verb|B| is the return type (allowed to depend on \verb|A| again), and \verb|f| is a function in the meta language of type \verb|x : A -> B x|.
	\item \verb|FnDestruct| takes four arguments: \verb|A| is the argument type, \verb|B| is the return type (allowed to depend on \verb|A| again), a term of type \verb|A -> B| and an argument of type \verb|A|. 
\end{enumerate}

Note that these constructors can only represent type-correct terms, \emph{intrinsically typed} terms. This is useful because it means the meta language does the type checking for us. The disadvantage is that it requires extra information: We need to give \verb|B| for \verb|FnConstruct| and \verb|A| and \verb|B| for \verb|FnDestruct|, which is information we don't have to provide to type-check terms in Statix. These could easily be automatically generated by a type checker but are tedious to specify manually. It seems like it should be possible to infer these, but lambdapi fails to do so. Further research is required to find out why lambdapi does not infer these.

\section{Reduction Rules}

We now define the \emph{reduction rules}, which define how to reduce the language. A rule $a \hookrightarrow b$ states that \verb|a| reduces to \verb|b|. We reduce the constructs in our language to constructors in lambdapi, this is called \emph{embedding} the language. Lambdapi can then evaluate the rules using its own semantics, not requiring any additional rules similar to the ones in figure \ref{fig:beta-head-reduce-rules}. It is also possible to define the rules in \ref{fig:beta-head-reduce-rules} using reduction rules, but this way of defining reduction rules is much simpler. The reduction rules are given in figure \ref{fig:lp-rules}. Each of the constructs is reduced to the corresponding construct in the meta language.

\begin{figure}[ht]
	\begin{lstlisting}
rule TmType Type `$\hookrightarrow$` TmSort;
rule TmType (FnType $A $B) `$\hookrightarrow$` `Π` (x : TmType $A), TmType ($B x);
rule FnConstruct _ _ $f `$\hookrightarrow$` $f;
rule FnDestruct _ _ $f $a `$\hookrightarrow$` $f $a;
	\end{lstlisting}
	\caption{Reduction Rules for the Calculus of Constructions}
	\label{fig:lp-rules}
\end{figure}

\section{\label{ch:comp-lambdapi:let}Defining Let Bindings}

Let bindings require substitution, which is not possible to encode in lambdapi. We can encode a less powerful version of let bindings, which are not substituted but evaluated via functions. The definition of this is given in figure \ref{fig:lp-let}. The body of the let binding is allowed to depend on a value of type \verb|A|, but it is not aware of the exact value \verb|v| of the let binding. 

\begin{figure}[ht]
	\begin{lstlisting}
symbol Let : 
	`Π` (A : TmSort), 
	`Π` (B : TmType A → TmSort), 
	`Π` (v : TmType A),
	`Π` (b : TmType A → TmType (B v)),
	TmType (B v);
rule Let _ _ $v $b `$\hookrightarrow$` $b $v;
	\end{lstlisting}
	\caption{Definition of less powerful Let in LambdaPi}
	\label{fig:lp-let}
\end{figure}

One program which would not type-check with this approach is the following. It fails to compile since it cannot know that \verb|b| is a boolean, which is required by the definition of f \footnote{Assuming we introduce booleans into the language, there are examples that don't require booleans but they are a bit more difficult to understand}.
\begin{lstlisting}
let T = Bool;
\f: Bool -> Bool;
\b: T. f b
\end{lstlisting}

We could solve this problem by not defining our program as an embedding, instead defining it using the reduction rules in figure \ref{fig:beta-head-reduce-rules}. This results in a definition very close to the one in Statix, except that instead of a beta reduction relation we use the reductions built-in to the language, which solves the problem. 

\section{Comparison}

In this chapter we've defined the calculus of constructions by embedding it into LambdaPi. This is a declarative definition, similarly to Statix and unlike Haskell. However, since we are embedding the language into LambdaPi, the dynamic semantics of the language are now defined in terms of the dynamic semantics of LambdaPi. This means that the features our language can have are limited by the features of LambdaPi, this means it was impossible to define \verb|Let| bindings the way we wanted to.

The static semantics of the language are defined by the way we create our terms. This is quite flexible, though less flexible than Statix since for example we have no control over the scoping rules (such as shadowing) of the language, which would be controlled by scope graphs in Statix. 

The conclusion is that embedding a language in LambdaPi is primarily useful if we want to verify the implementation of our language is correct, which is one of the primary use cases of LambdaPi. Using it as a compiler for the language is not the intention behind LambdaPi, which is clear from the limitations we've mentioned above. We believe this comparison was still insightful, as it shows how compact an implementation in Statix could be if Statix would have equational unification.

We've now discussed equational unification using lambdapi, which is a feature that we suggest could improve Statix. Other possible improvements are discussed in chapter \ref{ch:ergonomics}.