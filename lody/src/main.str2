module main

imports

  statixruntime
  statix/api
  injections/-
  signatures/-
  pp
  completion
  strategolib
  libstratego-gpp
  libspoofax/sdf/pp
  

rules // Analysis

//  pre-analyze  = id
//  post-analyze = id

  editor-analyze = stx-editor-analyze(pre-analyze, post-analyze|"main", "programOk")
  editor-resolve = stx-editor-resolve
  editor-hover   = stx-editor-hover
  
  
  get-type :: Expr -> Expr
  get-type : expr -> type' // Defines a rule which matches on node and returns type'
    with <debug(!"CHECKING: ")> <strip-annos> expr
    where
      // Assigns variable a to be the result of the Statix analysis of the entire program (or throws an error)
      a := <stx-get-ast-analysis <+ fail-msg(|$[no analysis on node [<strip-annos;write-to-string> expr]])>;
      // Gets the type of the given node (or throws an error)
      type := <stx-get-ast-type(|a) <+ fail-msg(|$[no type on node [<strip-annos;write-to-string> expr]])> expr;
      
      type' := <uniquify> (type, [])
    with <debug(!"RESULT: ")> <strip-annos> type
      
  fail-msg(|msg) = err-msg(|$[get-type: [msg]]); fail
  
  
  uniquify :: Expr * List(ID) -> Expr
  uniquify : (Type(), _) -> Type()
  uniquify : (FnDestruct(e1, e2), names) -> FnDestruct(<uniquify> (e1, names), <uniquify> (e2, names))
  
  uniquify : (Let(n1, a, b), names) -> Let(n2, <uniquify> (a, names), <uniquify> (b, [<strip-annos> n2 | names]))
  with <find-new-name> (n1, names) => n2
  with rules( Rename : n1 -> n2 )
  
  uniquify : (Var(n1), _) -> Var(n2)
  where <resolve-ref> n1 => d
  where <Rename> d => n2
  resolve-ref :: ID -> ID
  resolve-ref : node -> d
  where <stx-get-ast-analysis> node => analysis
  where <stx-get-ast-ref(|analysis); if is-list then Hd end> node => d
  
  uniquify : (FnConstruct(n1, et, eb), names) -> FnConstruct(n2, <uniquify> (et, names), <uniquify> (eb, [<strip-annos> n2 | names]))
  with <find-new-name> (n1, names) => n2
  with rules( Rename : n1 -> n2 )
  
  uniquify : (FnType(n1, et, eb), names) -> FnType(n2, <uniquify> (et, names), <uniquify> (eb, [<strip-annos> n2 | names]))
  with <find-new-name> (n1, names) => n2
  with <debug(!"RENAMED: ")> (<strip-annos> n1, <strip-annos> n2, <strip-annos> names)
  with rules( Rename : n1 -> n2 )
  
  find-new-name :: ID * List(ID) -> ID
  find-new-name : ("_", _) -> "_"
  find-new-name : (n1, names) -> n1
  where not(<elem> (<strip-annos> n1, names))
  find-new-name : (n1, names) -> <find-new-name> (n2, names)
  where <elem> (<strip-annos> n1, names)
  with n2 := <conc-strings> (n1, "'")
  
  
  
  // Defined for semantic code completion
  downgrade-placeholders = downgrade-placeholders-lody
  upgrade-placeholders   = upgrade-placeholders-lody
  is-inj                 = is-lody-inj-cons
  pp-partial             = pp-partial-lody-string
  pre-analyze            = explicate-injections-lody
  post-analyze           = implicate-injections-lody
  
  
  
  
  
  
  
  
  
  