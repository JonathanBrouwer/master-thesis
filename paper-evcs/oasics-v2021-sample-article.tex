
\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{oasics-v2021}
%This is a template for producing OASIcs articles. 
%See oasics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"
%for producing a PDF according the PDF/A standard, add "pdfa"

%\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
%\hideOASIcs %uncomment to remove references to OASIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

% Added because the included oasics-logo-bw.pdf is pdf 1.6 and this was giving a warning
% Feel free to remove this if it breaks anything
\pdfminorversion=6

\usepackage{mathpartir}

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Dependently Typed Languages in Statix} %TODO Please add

\author{Jonathan Brouwer}{Delft University of Technology, The Netherlands \and \url{http://jonathanb.nl}}{j.t.brouwer@student.tudelft.nl}{}{}

\author{Jesper Cockx}{Delft University of Technology, The Netherlands \and \url{http://jesper.sikanda.be}}{j.g.h.cockx@tudelft.nl}{}{}

\author{Aron Zwaan}{Delft University of Technology, The Netherlands \and \url{http://aronzwaan.github.io}}{a.s.zwaan@tudelft.nl}{}{}

\authorrunning{J. Brouwer, J. Cockx and A. Zwaan} 

\Copyright{Jonathan Brouwer, Jesper Cockx and Aron Zwaan} 
\begin{CCSXML}
    <ccs2012>
    <concept>
    <concept_id>10011007.10011006.10011039.10011311</concept_id>
    <concept_desc>Software and its engineering~Semantics</concept_desc>
    <concept_significance>500</concept_significance>
    </concept>
    <concept>
    <concept_id>10011007.10011006.10011008.10011009.10011012</concept_id>
    <concept_desc>Software and its engineering~Functional languages</concept_desc>
    <concept_significance>300</concept_significance>
    </concept>
    <concept>
    <concept_id>10011007.10011006.10011041</concept_id>
    <concept_desc>Software and its engineering~Compilers</concept_desc>
    <concept_significance>300</concept_significance>
    </concept>
    </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~Semantics}
\ccsdesc[300]{Software and its engineering~Functional languages}
\ccsdesc[300]{Software and its engineering~Compilers}

\keywords{Spoofax, Statix, Dependent Types} %TODO mandatory; please add comma-separated list of keywords

\nolinenumbers %uncomment to disable line numbering

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

\begin{abstract}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Praesent convallis orci arcu, eu mollis dolor. Aliquam eleifend suscipit lacinia. Maecenas quam mi, porta ut lacinia sed, convallis ac dui. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse potenti. 
\end{abstract}

\section{Introduction}

Spoofax is a textual language workbench: \label{key}a collection of tools that enable the development of textual languages\cite{spoofax}. When working with the Spoofax workbench, the Statix meta-language can be used for the specification of Static Semantics. To provide these advantages to as many language developers as possible, Statix aims to cover a broad range of languages and type-systems. However, no attempts have been made to express dependently typed languages in Statix. 

Dependently typed languages are different from other languages, because they allow types to be parameterized by values. This allows more rigorous reasoning over types and the values that are inhabited by a type. This expressiveness also makes dependent type systems more complicated to implement. Especially, deciding equality of types requires evaluation of the terms they are parameterized by. 

This goal of this paper is to investigate how well Statix is fit for the task of defining a simple dependently-typed language. We want to investigate whether typical features of dependently typed languages can be encoded concisely in Statix. The goal is not to show that Statix can implement it, but that implementing it is easier in Statix than in a general-purpose programming language. 

We will first show the base language and explain the way that Statix was used to implement this language. Next, we will explore several features and see how well they can be expressed in Statix.

\section{Calculus of Constructions}

The base language that was implemented is the Calculus of Constructions \cite{Coquand_Huet_1988}, the language at the top of the lambda cube. One extra feature was added that is not present in the Calculus of Constructions, let bindings.

\subsection{Scope Graphs}

To type-check the base language, we need to store information about the names we have encountered. There are two different situations, names that we encounter that do not have a known value (only a type), such as function arguments, and names that do have a known value, such as let bindings.\footnote{In non-dependent languages there is no such distinction, but because we may need to value of a binding to compare types, this is needed in dependently typed languages.}

Both of these need to be stored in the scope graph. The scope graph only has a single type of edge, called \verb|P| (parent) edges. It also only has a single relation, called \verb|name|. This name stores a \verb|NameEntry|, which can be either a \verb|NType|, which stores the type of a name, or a \verb|NSubst|, which stores a substitution corresponding to a name. 

\begin{lstlisting}
signature sorts	NameEntry
constructors    NType : Expr -> NameEntry
                NSubst : scope * Expr -> NameEntry
relations       name : ID -> NameEntry
name-resolution	labels P
\end{lstlisting}

These are all the definitions we will need to type-check programs. Next, we will introduce some Statix relations that can be used to interact with these scope graphs:

\begin{lstlisting}
sPutType  : scope * ID * Expr -> scope
sPutSubst : scope * ID * (scope * Expr) -> scope
sGetName  : scope * ID -> NameEntry
sGetNames : scope * ID -> list((path * (ID * NameEntry)))
sEmpty    : -> scope
\end{lstlisting}

The \verb|sPutType| and \verb|sPutSubsts| relations generate a new scope given a parent scope and a type or a substitution respectively. To query the scope graph, use \verb|sGetName| or \verb|sGetNames|, which will return a \verb|NameEntry| or a list of \verb|NameEntries| respectively that the query found. Finally, \verb|sEmpty| returns a fresh empty scope.

\subsection{Beta Reductions}

A unique requirement for dependently typed languages is beta reduction during type-checking, since types may require evaluation to compare. Beta reduction is done using Krivine abstract machines\cite{krivine}. We define a rule \verb|betaReduceHead|, that takes a scoped expression and a stack of applications. The scope acts as the environment from \cite{krivine} paper, using \verb|NSubst| to store substitutions. Furthermore, we can define \verb|expectBetaEq|, which asserts that two terms are equal. This calls \verb|expectBetaEq_| with \verb|betaReduceHead| applied.

\begin{lstlisting}
betaReduceHead : (scope * Expr) * list((scope * Expr))
                                     -> (scope * Expr)
expectBetaEq   : (scope * Expr) * (scope * Expr)
expectBetaEq(e1, e2) :- 
    expectBetaEq_(betaReduceHead(e1, []), betaReduceHead(e2, [])).
expectBetaEq_  : (scope * Expr) * (scope * Expr)
\end{lstlisting}	

\subsection{Type-checking programs}

We will define a Statix relation \verb|typeOfExpr| that takes a scope and an expression and type-checks the scope in the expression. It returns the type of the expression.

\begin{lstlisting}
typeOfExpr : scope * Expr -> Expr
\end{lstlisting}


We can then start defining concepts in this language. First, we present the inference rules of the language:

\begin{figure}

\begin{mathpar}
\inferrule{ }{s \vdash Type() : Type()}

\inferrule{ sPutSubst(s, n, (s, v)) \vdash b : t }{s \vdash Let(n, v, b) : t }

\inferrule{ sGetName(s, n) = NType(t) }{ s \vdash Var(n) : t }

\inferrule{ sGetName(s, n) = NSubst(se, e) \and se \vdash e : t }{ s \vdash Var(n) : t }

\inferrule{ s \vdash a : at \and at \underset{\beta}{=} Type() \and a \underset{\beta}{\Rightarrow} a' \and sPutType(s, n, a') \vdash b : bt \and bt \underset{\beta}{=} Type() } { s \vdash FnType(n, a, b) : Type() }

\inferrule{ s \vdash a : at \and at \underset{\beta}{=} Type() \and a \underset{\beta}{\Rightarrow} a' \and sPutType(s, n, a') \vdash b : bt } { s \vdash FnConstruct(n, a, b) : FnType(n, a', bt) }



\end{mathpar}
\caption{Rules for type-checking the Calculus of Constructions}
\label{fig:type-check-rules}
\end{figure}

\begin{figure}
\begin{mathpar}
\inferrule{ }{ s, Type(), [] \Rightarrow s, Type() }

\inferrule{ sPutSubst(s, n, (s, v)) \vdash b : t }{s \vdash Let(n, v, b) : t }
\end{mathpar}
\caption{Rules for beta reducing the Calculus of Constructions}
\label{fig:beta-head-rules}
\end{figure}







\bibliography{oasics-v2021-sample-article}

\end{document}
