\chapter{Calculus of Constructions in Statix}
\label{chap:baselang}

In this section, we will describe how to implement a dependently typed language in Statix. In section \ref{sec:coc-syntax} we will describe the syntax of the language, then in section \ref{sec:coc-scopes} we will describe how scope graphs are used to type check the language. Section \ref{sec:coc-dynsyms} describes the dynamic semantics of the language, and finally \ref{sec:coc-typecheck} how to type check the language. This chapter is the main contribution of this thesis.

\section{The Language}
\label{sec:coc-syntax}

The base language that has been implemented is the Calculus of Constructions~\cite{Coquand_Huet_1988}. One extra feature was added that is not present in the Calculus of Constructions: let bindings. Let bindings could be desugared by substituting, but this may grow the program size exponentially, so having them in the language is useful. The concrete syntax (written in SDF3~\cite{sdf3}) of the language is available in figure \ref{fig:syntax}.

\begin{figure}[h]
\begin{lstlisting}
Expr.Type = "Type"
Expr.Var = ID
Expr.FnType = ID ":" Expr "->" Expr {right}
Expr.FnConstruct = "\\" ID ":" Expr "." Expr
Expr.FnDestruct = Expr Expr {left}
Expr.Let = "let" ID "=" Expr ";" Expr
\end{lstlisting}
\caption{The concrete syntax for the base language. $\co{FnConstruct}$ is a lambda function, $\co{FnDestruct}$ is application of a lambda function.}
\label{fig:syntax}
\end{figure}

There is only one sort: Expr. The syntax definition does not have a separate sort for types, as types may be arbitrary expressions in a dependently typed language. The following constructors exist:
\begin{itemize}
	\item \verb|Type| is the Type of Types.
	\item \verb|Var| is a variable, it uses the lexical sort \verb|ID|, which is defined as \verb|[a-zA-Z\_][a-zA-Z0-9\_]*|.
	\item \verb|FnType| is the type of a function. It assigns a name to its first argument to allow the return type of the function to depend on the argument type. It is right associative, meaning \verb|A -> B -> C| is interpreted as \verb|A -> (B -> C)|. 
	\item \verb|FnConstruct| creates an anonymous function (lambda function).
	\item \verb|FnDestruct| applies a function to an argument. It is left associative, meaning \verb|a b c| is interpreted as \verb|(a b) c|.
	\item \verb|Let| is a let binding. It introduces a substitutable variable.
\end{itemize}

An example program is the following, which defines a polymorphic identity function (an identity function that is generic over its type) and applies it to a function:

\begin{lstlisting}
let f = \T: Type. \x: T. x;
f (T: Type -> Type) (\y: Type. y)
\end{lstlisting}

The type that the function is generic over needs to be explicitly specified. In most languages, generics are inferred, this inference will also be possible in this language after implementing inference in chapter~\ref{ch:inference}.

\section{Scope Graphs}
\label{sec:coc-scopes}

To type check the base language, we need an environment to store information about the names that are in scope at each point in the program. There are two different types of names that we may want to store, names that do not have a known value (only a type), which are names created by function arguments and dependent function types, and names that do have a known value, which are names created by let bindings.\footnote{In non-dependent languages there is no such distinction, but because we may need \emph{the value} of a binding to compare types, this is needed in dependently typed languages.}

In Statix, all this information can be stored in a \emph{scope graph}~\cite{scope_graphs}, as explained in chapter \ref{chap:bg-spoofax}. We only use a single type of edge, called \verb|P| (parent) edges. We also only have a single relation, called \verb|name|. The relation associates a \verb|NameEntry| with each name in the scope graph. The \verb|NameEntry| can be either a \verb|NType|, which stores the type of a name, or a \verb|NSubst|, which stores a name that has been substituted with a value. The Statix definition of these concepts is given below:
\begin{lstlisting}
constructors
    NType : Expr -> NameEntry
    NSubst : scope * Expr -> NameEntry
relations
    name : ID -> NameEntry
\end{lstlisting}

Next, we will introduce some Statix predicates that can be used to interact with these scope graphs:

\begin{lstlisting}
sPutType  : scope * ID * Expr -> scope
sPutSubst : scope * ID * (scope * Expr) -> scope
sGetName  : scope * ID -> NameEntry
sEmpty    : -> scope
\end{lstlisting}
The \verb|sPutType| and \verb|sPutSubst| predicates generate a new scope given a parent scope and a type or a substitution respectively. These return a scope that represent an environment that has been extended with the new name. To query the scope graph we use \verb|sGetName|, which will return the closest \verb|NameEntry| with a matching name. Finally, \verb|sEmpty| returns a fresh empty scope.

We will define a \emph{scoped expression}, as a pair of a scope and an expression. The scope acts as the environment of the expression, containing all of the context needed to evaluate the expression.

\section{Beta Reductions}
\label{sec:coc-dynsyms}

A unique requirement for dependently typed languages is beta reduction during type checking, since types may require evaluation to compare. Beta reduction is the process of reduction a term to its beta normal form, which is the state where no further beta reductions are possible~\cite{tapl}. It works by matching a term of the form \verb|(\x. b) e|. and substituting \verb|x| in \verb|b| with \verb|e|. Beta reduction applies this rule anywhere in the term, whereas beta head-reduction only applies this rule at the head (outermost expression) of the term, and produces a term in beta-head normal form.

We implemented beta-head reduction using a Krivine abstract machine~\cite{krivine}. The machine can head evaluate lambda expressions with a call-by-name semantics. This is a strategy under which the leftmost, outermost term is always reduced first~\cite{tapl}. It works by keeping a stack of all arguments that have not been applied yet. This turned out to be the more natural way of expressing this compared to substitution-based evaluation relation, which is an alternative we will discuss in section \ref{sec:coc-subst}.

In conventional dependently typed languages, evaluation is often done using De Bruijn indices, which use numbers to identify variables. However, we chose to use names rather than De Bruijn indices, because scope graphs work based on names. Using De Bruijn indices would also prevent us from using editor services that rely on \verb|.ref| annotations (which are Spoofax annotations that declare one name as being a use of another name that is a definition).

We need to define multiple predicates that will be used later for type checking. First, the primary predicate is \verb|betaReduceHead|, that takes a scoped expression and a stack of applications, and returns a head-normal expression. The scope acts as the environment from~\cite{krivine}, using \verb|NSubst| to store substitutions. All rules for \verb|betaReduceHead| are given in figure \ref{fig:beta-head-reduce-rules}. We use the syntax $\bhr{\scope{s_1}{e_1}}{\overline{p}}{\scope{s_2}{e_2}}$ to express \verb|betaReduceHead((s1, e1), ps) == (s2, e2)|. The $\overline{p}$ in this definition is the argument stack of the Krivine machine. The argument stack is a stack of scoped expressions, which are the arguments that are not yet paired with a matching function. Figure \ref{fig:beta-head-reduce-rules} contains the rules necessary for beta head reduction of the language. One predicate that is used for this is the \verb|rebuild| predicate, which takes a scoped expression and the stack of arguments (of the Krivine machine state) and converts it to an expression by adding \verb|FnDestruct|s. Its signature is:
\begin{lstlisting}
rebuild : (scope * Expr) * list((scope * Expr)) -> (scope * Expr)
\end{lstlisting}

Additionally, we define \verb|betaReduce| which fully beta reduces a term. It works by first calling \verb|betaReduceHead| and then matching on the head, calling \verb|betaReduce| on the sub-expressions of the head recursively.

\begin{figure}[h]
	\figuresection[\fbox{$\bhr{\scope{s_1}{e_1}}{\overline{p}}{\scope{s_2}{e_2}}$}]{Beta head-reduction rules}

	\begin{mathpar}
		% Type rule
		\inferrule{
		} {
			\bhr
			{ \scope{s}{\co{Type}()} }
			{ [] }
			{ \scope{s}{\co{Type}()}}
		}

		% Let rule
		\inferrule{
			\bhr
			{ \scope{ \co{sPutSubst}(s, x, (s, e))}{b} }
			{ \overline{p} }
			{ \scope{ s' } { b' } }
		}{
			\bhr
			{ \scope{ s }{ \co{Let}(x, e, b) } }
			{ \overline{p} }
			{ \scope { s' } { b' } }
		}

		% Var rule - NSubst
		\inferrule{
			\co{sGetName}(s, x) = \co{NSubst}(s_e, e)
			\\ \bhr
			{\scope{s_e}{e}}
			{\overline{p}}
			{\scope{s_{e'}}{e'}}
		}{
			\bhr
			{\scope{s}{\co{Var}(x)}}
			{\overline{p}}
			{\scope{s_{e'}}{e'}}
		}

		% Var rule - NType
		\inferrule{
			\co{sGetName}(s, x) = \co{NType}(t)
		}{
			\bhr
			{\scope{s}{\co{Var}(x)}}
			{\overline{p}}
			{\co{rebuild}(s, \co{Var}(x), \overline{p})}
		}

		% FnType rule
		\inferrule{
		} {
			\bhr
			{\scope{s}{\co{FnType}(x, a, b)}}
			{[]}
			{\scope{s}{\co{FnType}(x, a, b)}}
		}

		% FnConstruct rule - No args
		\inferrule{
		} {
			\bhr
			{\scope{s}{\co{FnConstruct}(x, a, b)}}
			{[]}
			{\scope{s}{\co{FnConstruct}(x, a, b)}}
		}

		% FnConstruct rule - Args
		\inferrule{
			\bhr
			{\scope{\co{sPutSubst}(s, x, p)}{b}}
			{\overline{p}}
			{\scope{s'}{e'}}
		} {
			\bhr
			{\scope{s}{\co{FnConstruct}(x, \_, b)}}
			{(p::\overline{p})}
			{\scope{s'}{e'}}
		}

		% FnDestruct rule
		\inferrule{
			\bhr
			{\scope{s}{f}}
			{(a::\overline{p})}
			{\scope{s'}{e'}}
		} {
			\bhr
			{\scope{s}{\co{FnDestruct}(f, a)}}
			{\overline{p}}
			{\scope{s'}{e'}}
		}
	\end{mathpar}
	\caption{Rules for beta head reducing the Calculus of Constructions}
	\label{fig:beta-head-reduce-rules}
\end{figure}

\section{Beta Equality}
\label{sec:coc-betaeq}

We need to define \verb|expectBetaEq|, which asserts that two scoped expressions are equal under beta reduction. This rule first beta reduces the heads of both sides, and then compares them. If the head is not the same, the rule fails. Otherwise, it recurses on the sub-expressions. One special case is when comparing two \verb|FnConstruct|s. Here we need to take into account alpha equality: two expressions which only differ in the names that they use should be considered equal. We implement this by substituting in the body of the functions, replacing their argument names with a unique placeholder.

This substitution is called \verb|AlphaEqVars : ID * ID -> Expr|. The combination of the ID on the left and right hand side of the equality guarantees that the substitution is unique. In figure \ref{fig:beta-eq-rules} we show how \verb|AlphaEqVars| is used to determine equality of functions.

\begin{figure}[h]
	\figuresection[\fbox{$\beq{\scope{s_1}{e_1}}{\scope{s_2}{e_2}}$}]{Beta equality rules}
	
	\begin{mathpar}
		\inferrule{
		} {
			\beq
			{ \co{AlphaEqVars}(x_1, x_2) }
			{ \co{AlphaEqVars}(x_1, x_2) }
		}
	
		\inferrule{
			\beq{\scope{s_1}{a_1}}{\scope{s_2}{a_2}}
			\\\\ s_1' = \co{sPutSubst}(s_1, x_1, (\co{sEmpty}(), \co{AlphaEqVars}(x_1, x_2)))
			\\\\ s_2' = \co{sPutSubst}(s_2, x_2, (\co{sEmpty}(), \co{AlphaEqVars}(x_1, x_2)))
			\\\\ \beq{
				\scope{s_1'}{b_1}
				}{ 
				\scope{s_2'}{b_2}
			}
		} {
			\beq
			{ \scope{s_1}{\co{FnType}(x_1, a_1, b_1)} }
			{ \scope{s_2}{\co{FnType}(x_1, a_2, b_2)} }
		}
	
		\inferrule{
			\beq{\scope{s_1}{a_1}}{\scope{s_2}{a_2}}
			\\\\ s_1' = \co{sPutSubst}(s_1, x_1, (\co{sEmpty}(), \co{AlphaEqVars}(x_1, x_2)))
			\\\\ s_2' = \co{sPutSubst}(s_2, x_2, (\co{sEmpty}(), \co{AlphaEqVars}(x_1, x_2)))
			\\\\ \beq{
				\scope{s_1'}{b_1}
			}{ 
				\scope{s_2'}{b_2}
			}
		} {
			\beq
			{ \scope{s_1}{\co{FnConstruct}(x_1, a_1, b_1)} }
			{ \scope{s_2}{\co{FnConstruct}(x_1, a_2, b_2)} }
		}
	\end{mathpar}

	\caption{Rules for beta equality in the Calculus of Constructions}
	\label{fig:beta-eq-rules}
\end{figure}

\section{Type Checking}
\label{sec:coc-typecheck}

We will define a Statix predicate \verb|typeOfExpr| that takes a scope and an expression and type checks the expression in the scope. It returns the type of the expression.

\begin{lstlisting}
typeOfExpr : scope * Expr -> Expr
\end{lstlisting}
We can then start defining type checking rules for the language. We introduce a number of judgements for typing and equality together with their counterparts in Statix.
\begin{enumerate}
	\item $\toe{s}{e}{t}$ is the same as \verb|typeOfExpr(s, e) == t|
	\item $\beq{\scope{s1}{e1}}{\scope{s2}{e2}}$ is the same as \verb|expectBetaEq((s1, e1), (s2, e2))|
	\item $\bhr{\scope{s1}{e1}}{\overline{p}}{\scope{s2}{e2}}$ is the same as \verb|betaReduceHead((s1, e1), ps) == (s2, e2)| \\ (The same as in section \ref{sec:coc-dynsyms})
	\item $\bred{s1}{e1}{e2}$ is the same as \verb|betaReduce((s1, e1)) == e2|
	\item $\scope{sEmpty}{e}$ is the same as $e$ (empty scopes can be left out)
\end{enumerate}

One thing to note is that some rules use \verb|betaReduce|. The goal of this beta reduce is to make the term into a term that does not need an environment (by substituting all let bindings). A full beta reduce is not necessary, but this is merely a performance optimization.

The inference rules in figures \ref{fig:beta-head-reduce-rules}, \ref{fig:beta-eq-rules}, and \ref{fig:type-check-rules} can be directly translated to Statix rules. For example, the rule for \verb|Let| bindings in figure \ref{fig:type-check-rules} is expressed like this in Statix:
\begin{lstlisting}
typeOfExpr(s, Let(n, v, b)) = typeOfExpr(s', b) :-
    typeOfExpr(s, v) == vt, sPutSubst(s, n, (s, v)) == s'.
\end{lstlisting}

\begin{figure}[h]
	\figuresection[\fbox{$\toe{s}{e}{t}$}]{Type checking rules}
	\begin{mathpar}
		\mprset{vskip=0.7ex}
		% Type rule
		\inferrule{
		} {
			\toe{s}{\co{Type}()}{\co{Type}()}
		}

		% Let rule
		\inferrule{
			\toe{s}{e}{t_e}
			\\ \toe{\co{sPutSubst}(s, x, (s, e))}{b}{t_b}
		}{
			\toe{s}{\co{Let}(x, e, b)}{t_b}
		}

		\\

		% Var rule - NType
		\inferrule{
			\co{sGetName}(s, x) = \co{NType}(t)
		}{
			\toe{s}{\co{Var}(x)}{t}
		}

		% Var rule - NSubst
		\inferrule{
			\co{sGetName}(s, x) = \co{NSubst}(s_e, e)
			\\ \toe{s_e}{e}{t}
		}{
		 	\toe{s}{\co{Var}(x)}{t}
		}

		% FnType rule

		\inferrule{
			\toe{s}{a}{t_a}
			\\ \beq{t_a}{\co{Type}()}
			\\ \bred{s}{a}{a'}
			\\\\ \toe{\co{sPutType}(s, x, a')}{b}{t_b}
			\\ \beq{t_b}{\co{Type}()}
		} {
			\toe{s}{\co{FnType}(x, a, b)}{\co{Type}()}
		}


		% Force these to be on the same line, using negative spaces
		\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!


		% FnConstruct rule
		\inferrule{
			\toe{s}{a}{t_a}
			\\ \beq{t_a}{\co{Type}()}
			\\ \bred{s}{a}{a'}
			\\\\ \toe{\co{sPutType}(s, x, a')}{b}{t_b}
		} {
			\toe{s}{\co{FnConstruct}(x, a, b)}{\co{FnType}(x, a', t_b)}
		}

		% FnDestruct rule
		\inferrule{
			\toe{s}{f}{t_f}
			\\ \bhr
				{\scope{s}{t_f}}
				{[]}
				{\scope{s_f}{\co{FnType}(x, t_{da}, t_b)}}
			\\\\ \toe{s}{a}{t_a}
			\\ \beq{t_a}{\scope{s_f}{t_{da}}}
			\\ \bred{\co{sPutSubst}(s_f, x, (s, a))}{t_b}{t_b'}
		} {
			\toe{s}{\co{FnDestruct}(f, a)}{t_b'}
	 	}

		\mprset{vskip=0ex}
	\end{mathpar}
	\caption{Rules for type checking the Calculus of Constructions}
	\label{fig:type-check-rules}
\end{figure}

\section{Discussion of a Substitution-Based Approach}
\label{sec:coc-subst}

An alternative for a Krivine machine, which keeps a stack of arguments it has encountered, is a substitution-based relation. This beta-reduces a \verb|FnDestruct| by doing a nested beta-reduction of the function, and substituting into that, as is shown in figure \ref{fig:subst-approach}.

Although these rules look cleaner, they are more complicated to implement, requiring a separate relation to check if \verb|f| is a \verb|FnConstruct| or something else. For the pure calculus of constructions this still works quite well, but when adding inductive datatypes (chapter \ref{ch:datatypes}) the rules required become a lot more complex than those for a Krivine machine.

An additional benefit of Krivine machines is that the run-time performance of them tends to be a bit higher, though this is only a constant factor and not a time-complexity improvement.

\begin{figure}[h]
	\figuresection[\fbox{$\bhr{\scope{s_1}{e_1}}{}{\scope{s_2}{e_2}}$}]{A substitution-based approach for beta reduction}
	\begin{mathpar}
		\mprset{vskip=0.7ex}
		
		\inferrule{
			\bhr
			{\scope{s}{f}}{}
			{\scope{s_{f'}}{\co{FnConstruct}(x, \_, b)}}
			\\ \bhr
			{\scope{\co{sPutSubst}(s_{f'}, x, (s, a))}{b}}{}
			{\scope{s_{b'}}{b'}}
		} {
			\bhr
			{\scope{s}{\co{FnDestruct}(f, a)}}{}
			{\scope{s_{b'}}{b'}}
		}
	
		\inferrule{
			\bhr
			{\scope{s}{f}}{}
			{\scope{s_{f'}}{f'}}
			\\ \nexists x \, e_1 \, e_2. \, \, f' = \co{FnConstruct}(x, e_1, e_2)
		} {
			\bhr
			{\scope{s}{\co{FnDestruct}(f, a)}}{}
			{\scope{s}{\co{FnDestruct}(f, a)}}{}
		}
	
		\inferrule{
		} {
			\bhr
			{\scope{s}{\co{FnConstruct}(x, a, b)}}{}
			{\scope{s}{\co{FnConstruct}(x, a, b)}}{}
		}
		
		\mprset{vskip=0ex}
	\end{mathpar}
	\caption{A substitution-based approach for beta reduction}
	\label{fig:subst-approach}
\end{figure}


