module type_check/tp_datatypes

imports
  signatures/start-sig
  type_check/beta_eq
  type_check/scopes
  type_check/type_check
  type_check/tp_fn
  
rules

  //---- Type of DataType
  // A datatype is a type
  typeOfExpr_(_, e@DataType(_, _, _)) = (e, Type()).
  
  // If we find a declaration
  typeOfExpr_(s, DataTypeDecl(n, ps, cs, b)) = (DataTypeDecl(n', ps', cs', b'), b_type) :- {s1 s2 s3 s4}
  	scopeName(s2, n) == n',

	// Declare datatype
  	sPutType(s, n', createCoreType(Type(), ps')) == s1,
  	sPutDataTypeDecl(s1, n', DataType(n', ps', cs')) == s2,
  	
  	// Typecheck params in s, add their definitions to s2
  	dataTypeParams(s2, ps) == (s3, ps'),
  	
  	// Add all constructors to s2 to create s4. Type check them in the context of s3.
  	dataTypeConstrs(n', s3, s2, cs, createCoreElim(Var(n'), ps'), ps') == (s4, cs'),
  	
  	// Type check body in s4
  	typeOfExpr(s4, b) == (b', b_type).
  	
  // Creates the Expression `T -> e`
  createCoreType : Expr * list(DataParam) -> Expr
  createCoreType(c, []) = c.
  createCoreType(c, [Param(p, e) | ps]) = FnType(p, e, createCoreType(c, ps)).
  	
  // scope to put def * params -> scope that def was put * checked params
  dataTypeParams : scope * list(DataParam) -> (scope * list(DataParam))
  dataTypeParams(s, []) = (s, []).
  dataTypeParams(s, [Param(n, e) | ps]) = (s'', [Param(n', e') | ps']) :- {s'}
  	scopeName(s, n) == n',
  	typeOfExpr(s, e) == (e', _),
  	sPutType(s, n', e') == s',
  	dataTypeParams(s', ps) == (s'', ps').
  
  	
  // We want to put all the constructors in the second scope, the first scope is the context to check the constructors in (constructors cannot see eachother)
  dataTypeConstrs : ID * scope * scope * list(DataConstructor) * Expr * list(DataParam) -> (scope * list(DataConstructor))
  dataTypeConstrs(_, _, s, [], _, _) = (s, []).
  dataTypeConstrs(dn, sb, s, [Constructor(n, e) | cs], c, ps) = (s'', [Constructor(n', e') | cs']) :- {s' e_type e''}
  	scopeName(s', n) == n',
  	
  	typeOfExpr(sb, e) == (e', e_type),
  	checkConstructorPositive(c, dn, e'),
  	expectBetaEq((sEmpty(), e_type), (sEmpty(), Type())),
  	
  	createCoreType(e', ps) == e'',
  	sPutType(s, n', betaReduce((sb, e''))) == s',
  	dataTypeConstrs(dn, sb, s', cs, c, ps) == (s'', cs').
  	
  // Creates the expression `Maybe T1 T2..`
  createCoreElim : Expr * list(DataParam) -> Expr
  createCoreElim(c, []) = c.
  createCoreElim(c, [Param(p, e) | ps]) = createCoreElim(FnDestruct(c, Var(p)), ps).
  
  	
  // Check if a specific constructor is strictly positive'
  // c = Core elim
  checkConstructorPositive : Expr * ID * Expr
  checkConstructorPositive(c, _, c).
  checkConstructorPositive(c, n, FnType(_, c, b)) :- checkConstructorPositive(c, n, b).
  checkConstructorPositive(c, n, FnType(_, e, b)) :- 
  	checkConstructorPositiveSub(n, e),
  	checkConstructorPositive(c, n, b).
  
  // Check if a specific constructor does not reference the ID
  checkConstructorPositiveSub : ID * Expr
  checkConstructorPositiveSub(n, Var(m)) :- n != m.
  checkConstructorPositiveSub(n, FnType(_, e1, e2)) :- 
  	checkConstructorPositiveSub(n, e1),
  	checkConstructorPositiveSub(n, e2).
  checkConstructorPositiveSub(n, Type()).
  checkConstructorPositiveSub(n, BoolType()).
   	
  // -- Type of DataElim
  // We need to generate the type of the eliminator
  // It is beta reduced since it may contain variables
  typeOfExpr_(s, DataElim(n)) = (DataElim(n'), betaReduce((s, t))) :- {ps cs sp p c}
  	sGetDataTypeDecl(s, n) == DataType(n', ps, cs),
  	new sp, p == ScopedName(sp, "P"),
  	c == createCoreElim(Var(n'), ps),
  	t == parameterElimsGen(ps, FnType(p, FnType(Syn("_"), c, Type()), dataTypeElimsGen(c, p, cs))).
  	
  parameterElimsGen : list(DataParam) * Expr -> Expr
  parameterElimsGen([], c) = c.
  parameterElimsGen([Param(n, e) | ps], c) = FnType(n, e, parameterElimsGen(ps, c)).
  	
  // core elim of datatype, name of P function, list of data constructors left, generate the rest of the function
  dataTypeElimsGen : Expr * ID * list(DataConstructor) -> Expr
  // generate the `v -> P v` part of the function
  dataTypeElimsGen(d, p, []) = FnType(Syn("v"), d, FnDestruct(Var(p), Var(Syn("v")))).
  // generate the next constructor, using dataTypeElimsGenSub to find the constructor
  dataTypeElimsGen(d, p, [Constructor(c, e) | cs]) = FnType(Syn("_"), dataTypeElimsGenSub(d, p, e, Var(c)), dataTypeElimsGen(d, p, cs)).
  
  // core elim of datatype, name of P function, constructor expression, the expression that is being built (starting with the constructor name, applying arguments)
  dataTypeElimsGenSub : Expr * ID * Expr * Expr -> Expr
  // Sub is the return type. We want to generate `P (C ...)`
  dataTypeElimsGenSub(d, p, d, base) = FnDestruct(Var(p), base).
  // Sub is a FnType with a == n. We generate:
  // m: a (= n) -> _: p m -> rest
  dataTypeElimsGenSub(d, p, FnType(m, d, b), base) = 
  	FnType(m, d, 
  		FnType(Syn("_"), FnDestruct(Var(p), Var(m)),
  			dataTypeElimsGenSub(d, p, b, FnDestruct(base, Var(m)))
  		)
  	).
  // Sub is a FnType a != n. We generate:
  // m: a -> rest
  // We add `(base m)` to the rest
  dataTypeElimsGenSub(d, p, FnType(m, a, b), base) = FnType(m, a, dataTypeElimsGenSub(d, p, b, FnDestruct(base, Var(m)))).
  
  // -- Beta reduction rules
  betaReduceHead((s, e@DataType(n, ps, cs)), []) = (s, DataType(n, ps, cs)).
  
  betaReduceHead((s, e@DataElim(n)), as) = betaReduceHeadChoose((s, e), as, bhrCheck(ps, cs, cs, as)) :-
  	sGetDataTypeDecl(s, n) == DataType(n, ps, cs).
  	
  betaReduceHeadChoose : (scope * Expr) * list((scope * Expr)) * int -> (scope * Expr)
  betaReduceHeadChoose(e, as, 0) = kRebuild(e, as).
  betaReduceHeadChoose((s, DataElim(n)), as, 1) = betaReduceHead(brhDo(s, n, cs, a, (vn, v), [p | a]), r) :- {ps}
  	sGetDataTypeDecl(s, n) == DataType(n, ps, cs),
  	
  	bhrDataSplitArgs(as, ps, cs, 0) == (p, a, v, r),
  	brhDataCoreV(v) == vn.
  	
  	
  // CHECKS IF WE HAVE ENOUGH ARGUMENTS
  // Given constructors and arguments, we need at least len(constructors) + 2 arguments
  bhrCheck : list(DataParam) * list(DataConstructor) * list(DataConstructor) * list((scope * Expr)) -> int
  // Skip data params
  bhrCheck([_|ps], cso, cs, [_ | as]) = bhrCheck(ps, cso, cs, as).
  bhrCheck([_|ps], cso, cs, []) = 0.
  // Skip one constructor, skip one argument
  bhrCheck([], cso, [_ | cs], [_ | as]) = bhrCheck([], cso, cs, as).
  // We have enough, check if v is fine!
  bhrCheck([], cso, [], [_, v | _]) = bhrCheckV(cso, betaReduceHead(v, [])).
  // Not enough
  bhrCheck([], cso, [], [_]) = 0.     // no cs, 1 arg
  bhrCheck([], cso, _, [])   = 0.     // no args
  
  bhrCheckV : list(DataConstructor) * (scope * Expr) -> int
  bhrCheckV([], (s, Var(n))) = 0.
  bhrCheckV([Constructor(n, _) | _], (s, Var(n))) = 1.
  bhrCheckV([Constructor(_, _) | cs], (s, Var(n))) = bhrCheckV(cs, (s, Var(n))).
  bhrCheckV(cs, (s, FnDestruct(f, _))) = bhrCheckV(cs, betaReduceHead((s, f), [])).
  
  
  // FINDS MATCHING CONSTRUCTOR
  // Given a
  // - Data type name
  // - Constructors of datatype
  // - Args applied to elimination
  // - Value that is elimininated, split up in original value and constructor name
  // - List of arguments to the original function, for recursive applications
  // Returns beta reduced value
  brhDo : scope * ID * list(DataConstructor) * list((scope * Expr)) * (ID * (scope * Expr)) * list((scope * Expr)) -> (scope * Expr)
  
  // Constructor matches, use brhDo2 on the result
  brhDo(s, n, [Constructor(c, ce) | cs], [a | as], (c, ve), ar) = brhDo2(s, n, ce, a, betaReduceHead(ve, []), ar).
  // Constructor does not match, skip
  brhDo(s, n, [Constructor(_, ce) | cs], [_ | as], (c, ve), ar) = brhDo(s, n, cs, as, (c, ve), ar).
  
  // APPLIES ARGUMENTS TO FUNCTION
  // Given a
  // - Data type name
  // - Constructor definition expression
  // - Function .. -> .. -> p (constructor) that was given to the eliminator for constructor
  // - Value that is elimininated, original value
  // - List of arguments to the original function, for recursive applications
  // Returns beta reduced value
  brhDo2 : scope * ID * Expr * (scope * Expr) * (scope * Expr) * list((scope * Expr)) -> (scope * Expr)
  brhDo2(s, n, Var(n), f, (vs, Var(_)), _) = f.
  brhDo2(s, n, FnType(_, Var(n), c), f, (vs, FnDestruct(vf, va)), ar) = brhDo2(s, n, c, kApply(kApply(f, (vs, va)), r), betaReduceHead((vs, vf), []), ar) :-
  	r == betaReduceHead((s, DataElim(n)), append(ar, (vs, va))).
  brhDo2(s, n, FnType(_, _, c), f, (vs, FnDestruct(vf, va)), ar) = brhDo2(s, n, c, kApply(f, (vs, va)), betaReduceHead((vs, vf), []), ar).
  
 
  
  // Arguments look like PS P AS V R
  // Function returns P AS V R
  bhrDataSplitArgs : list((scope * Expr)) * list(DataParam) * list(DataConstructor) * int -> ((scope * Expr) * list((scope * Expr)) * (scope * Expr) * list((scope * Expr)))
  bhrDataSplitArgs([_|as], [_|ps], cs, 0) = bhrDataSplitArgs(as, ps, cs, 0). // skip ps arg
  bhrDataSplitArgs([p|as], [], cs, 0) = (p, r1, r2, r3) :-                   // grab p arg
  	bhrDataSplitArgs(as, [], cs, 1) == (_, r1, r2, r3).     
  bhrDataSplitArgs([a|as], [], [_|cs], 1) = (_, [a|r1], r2, r3) :-              // grab a arg
  	bhrDataSplitArgs(as, [], cs, 1) == (_, r1, r2, r3).
  bhrDataSplitArgs([v|rs], [], [], 1) = (_, [], betaReduceHead(v, []), rs).                         // grab v arg
  
  // Get the `v` argument from the `v` argument applied to things
  brhDataCoreV : (scope * Expr) -> ID
  brhDataCoreV((s, FnDestruct(f, a))) = brhDataCoreV(betaReduceHead((s, f), [])).
  brhDataCoreV((s, Var(n))) = n.
  
  append : list((scope * Expr)) * (scope * Expr) -> list((scope * Expr))
  append([], x) = [x].
  append([e | es], x) = [e | append(es, x)].
  

  betaReduce_((s, e@DataType(_, _, _))) = e.
  betaReduce_((s, e@DataElim(_))) = e.
  expectBetaEq_((_, DataType(n, _, _)), (_, DataType(n, _, _))).
  
  
  
  