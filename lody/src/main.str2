module main

imports

  statixruntime
  statix/api
  injections/-
  signatures/-
  pp
  completion
  strategolib
  libstratego-gpp
  libspoofax/sdf/pp
  
signature constructors
  Infer : Expr -> Expr
  ScopedName : ? * RID -> ID

rules // Analysis

  pre-analyze  = id
  post-analyze = id
  
  pre-analyze  = explicate-injections-lody
  post-analyze = implicate-injections-lody

  editor-analyze = stx-editor-analyze(pre-analyze, post-analyze|"main", "programOk")
  editor-resolve = stx-editor-resolve
  
  editor-hover : x -> <conc-strings> (<stx-editor-hover> x, " --- ", <stx-editor-hover(|"Inferred") <+ !""> x)
  
//  get-type :: Expr -> Expr
  get-type : expr -> type' // Defines a rule which matches on node and returns type'
    with <debug(!"CHECKING: ")> expr
    where
      // Assigns variable a to be the result of the Statix analysis of the entire program (or throws an error)
      a := <stx-get-ast-analysis <+ fail-msg(|$[no analysis on node [<strip-annos;write-to-string> expr]])>;
      // Gets the type of the given node (or throws an error)
      type := <stx-get-ast-type(|a) <+ fail-msg(|$[no type on node [<strip-annos;write-to-string> expr]])> expr;
      
      type' := <uniquify> <strip-annos> type
//      type' := <strip-annos> type
      
  fail-msg(|msg) = err-msg(|$[get-type: [msg]]); fail
  
  // Defined for semantic code completion
  downgrade-placeholders = downgrade-placeholders-lody
  upgrade-placeholders   = upgrade-placeholders-lody
  is-inj                 = is-lody-inj-cons
  pp-partial             = pp-partial-lody-string  

//  remove-syns-sub : Syn(n) -> n
//  remove-syns-sub : x -> x
//  remove-syns = bottomup(try(remove-syns-sub))
  
  
  uniquify-sub :: ? -> ?
  uniquify-sub : s -> s'
  where <is(ID)> s
  where not(<Rename> s)
  with <gen-name> s => s'
  with <debug(!"RENAME: ")> (s, s')
  with rules( Rename : s -> s' )
  
  uniquify-sub : s -> s''
  where <is(ID)> s
  where <Rename> s => s''
  
  uniquify :: ? -> ?
  uniquify = topdown(try(uniquify-sub))
  
  gen-name :: ID -> string
  gen-name : Syn(s) -> <gen-name-s> s
  gen-name : ScopedName(_, s) -> <gen-name-s> s
  
  gen-name-s :: string -> string
  gen-name-s : "_" -> "_"
  gen-name-s : s -> s
  where not(<RenameTaken> s)
  with rules( RenameTaken : s -> s )
  gen-name-s : s -> <gen-name-s> s'
  where <RenameTaken> s
  with <conc-strings> (s, "'") => s'
  
  
  

//  uniquify :: ? * List(ID) -> ?
//  uniquify : (Type(), _) -> Type()
//  uniquify : (FnDestruct(e1, e2), names) -> FnDestruct(<uniquify> (e1, names), <uniquify> (e2, names))
//  
//  uniquify : (BoolType(), names) -> BoolType()
//  uniquify : (BoolTrue(), names) -> BoolTrue()
//  uniquify : (BoolFalse(), names) -> BoolFalse()
//  uniquify : (BoolIf(c, e1, e2), names) -> BoolIf(<uniquify> (c, names), <uniquify> (e1, names), <uniquify> (e2, names))
//  
//  
//  uniquify : (Let(n1, a, b), names) -> Let(n2, <uniquify> (a, names), <uniquify> (b, [<strip-annos> n2 | names]))
//  with <find-new-name> (n1, names) => n2
//  with rules( Rename : n1 -> n2 )
//  
//  uniquify : (Var(n1), _) -> Var(n2)
//  where <resolve-ref> n1 => d
//  where <Rename> d => n2
  
//  
//  uniquify : (FnConstruct(n1, et, eb), names) -> FnConstruct(n2, <uniquify> (et, names), <uniquify> (eb, [<strip-annos> n2 | names]))
//  with <find-new-name> (n1, names) => n2
//  with rules( Rename : n1 -> n2 )
//  
//  uniquify : (FnType(n1, et, eb), names) -> FnType(n2, <uniquify> (et, names), <uniquify> (eb, [<strip-annos> n2 | names]))
//  with <find-new-name> (n1, names) => n2
//  with <debug(!"RENAMED: ")> (<strip-annos> n1, <strip-annos> n2, <strip-annos> names)
//  with rules( Rename : n1 -> n2 )
//  
//  find-new-name :: string * List(string) -> string
//  find-new-name : ("_", _) -> "_"
//  find-new-name : (n1, names) -> n1
//  where not(<elem> (<strip-annos> n1, names))
//  find-new-name : (n1, names) -> <find-new-name> (n2, names)
//  where <elem> (<strip-annos> Syn(n1), names)
//  with n2 := <conc-strings> (n1, "'")



  
  
