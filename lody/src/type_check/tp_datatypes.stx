module type_check/tp_datatypes

imports
  signatures/start-sig
  type_check/beta_eq
  type_check/scopes
  type_check/type_check
  type_check/tp_fn
  
rules

  //---- Type of DataType
  // A datatype is a type
  typeOfExpr_(_, e@DataType(_, _)) = (e, Type()).
  
  // If we find a declaration
  typeOfExpr_(s, DataTypeDecl(n, cs, b)) = (DataTypeDecl(n', cs', b'), b_type) :- {s' s''}
  	scopeName(s', n) == n',
  	
  	sPutSubst(s, n', (s, DataType(n', cs'))) == s',
  	dataTypeConstrs(n', s', s', cs) == (s'', cs'),
  	typeOfExpr(s'', b) == (b', b_type).
  	
  // We want to put all the constructors in the second scope, the first scope is the context to check the constructors in (constructors cannot see eachother0
  dataTypeConstrs : ID * scope * scope * list(DataConstructor) -> (scope * list(DataConstructor))
  dataTypeConstrs(_, _, s, []) = (s, []).
  dataTypeConstrs(dn, sb, s, [Constructor(n, e) | cs]) = (s'', [Constructor(n', e') | cs']) :- {s' e_type}
  	scopeName(s', n) == n',
  	
  	typeOfExpr(sb, e) == (e', e_type),
  	checkConstructorPositive(dn, e'),
  	expectBetaEq((sEmpty(), e_type), (sEmpty(), Type())),
  	
  	sPutType(s, n', betaReduce((sb, e'))) == s',
  	dataTypeConstrs(dn, sb, s', cs) == (s'', cs').// | error $[Constructor [n] of datatype [dn] is not strictly positive.].
  	
  // Check if a specific constructor is strictly positive
  checkConstructorPositive : ID * Expr
  checkConstructorPositive(n, Var(n)).
  checkConstructorPositive(n, FnType(_, Var(n), b)) :- checkConstructorPositive(n, b).
  checkConstructorPositive(n, FnType(_, e, b)) :- 
  	checkConstructorPositiveSub(n, e),
  	checkConstructorPositive(n, b).
  
  // Check if a specific constructor does not reference the ID
  checkConstructorPositiveSub : ID * Expr
  checkConstructorPositiveSub(n, Var(m)) :- n != m.
  checkConstructorPositiveSub(n, FnType(_, e1, e2)) :- 
  	checkConstructorPositiveSub(n, e1),
  	checkConstructorPositiveSub(n, e2).
  checkConstructorPositiveSub(n, Type()).
  checkConstructorPositiveSub(n, BoolType()).
   	
  // -- Type of DataElim
  // We need to generate the type of the eliminator
  // It is beta reduced since it may contain variables
  typeOfExpr_(s, DataElim(id)) = (DataElim(n), betaReduce((s, t))) :- {cs sp p}
  	sGetName(s, id) == (NameSubst(_, DataType(n, cs)), _),
  	new sp, p == ScopedName(sp, "P"),
  	t == FnType(p, FnType(Syn("_"), Var(n), Type()), dataTypeElimsGen(n, p, cs)).
  	
  // name of datatype, name of P function, list of data constructors left, generate the rest of the function
  dataTypeElimsGen : ID * ID * list(DataConstructor) -> Expr
  // generate the `v -> P v` part of the function
  dataTypeElimsGen(n, p, []) = FnType(Syn("v"), Var(n), FnDestruct(Var(p), Var(Syn("v")))).
  // generate the next constructor, using dataTypeElimsGenSub to find the constructor
  dataTypeElimsGen(n, p, [Constructor(c, e) | cs]) = FnType(Syn("_"), dataTypeElimsGenSub(n, p, e, Var(c)), dataTypeElimsGen(n, p, cs)).
  
  // name of datatype, name of P function, constructor expression, the expression that is being built (starting with the constructor name, applying arguments)
  dataTypeElimsGenSub : ID * ID * Expr * Expr -> Expr
  // Sub is the return type. We want to generate `P (C ...)`
  dataTypeElimsGenSub(n, p, Var(n), base) = FnDestruct(Var(p), base).
  // Sub is a FnType with a == n. We generate:
  // m: a (= n) -> _: p m -> rest
  dataTypeElimsGenSub(n, p, FnType(m, Var(n), b), base) = 
  	FnType(m, Var(n), 
  		FnType(Syn("_"), FnDestruct(Var(p), Var(m)),
  			dataTypeElimsGenSub(n, p, b, FnDestruct(base, Var(m)))
  		)
  	).
  // Sub is a FnType a != n. We generate:
  // m: a -> rest
  // We add `(base m)` to the rest
  dataTypeElimsGenSub(n, p, FnType(m, a, b), base) = FnType(m, a, dataTypeElimsGenSub(n, p, b, FnDestruct(base, Var(m)))).
  
  // -- Beta reduction rules
  betaReduceHead((s, e@DataType(n, cs)), []) = (s, DataType(n, cs)).
  
  betaReduceHead((s, e@DataElim(_)), as) = betaReduceHeadChoose((s, e), as, 1).
  betaReduceHeadChoose : (scope * Expr) * list((scope * Expr)) * int -> (scope * Expr)
  betaReduceHeadChoose(e, as, 0) = kRebuild(e, as).
  betaReduceHeadChoose((s, DataElim(n)), as, 1) = betaReduceHead(brhDo(s, n, cs, as, (vn, va), [va | a]), r) :-
  	sGetName(s, n) == (NameSubst(_, DataType(n, cs)), _),
  	brhDoGetAVR(cs, as) == (a, (vn, va), r).
  
  
  // FINDS MATCHING CONSTRUCTOR
  // Given a
  // - Data type name
  // - Constructors of datatype
  // - Args applied to elimination
  // - Value that is elimininated, split up in original value and constructor name
  // - List of arguments to the original function, for recursive applications
  // Returns beta reduced value
  brhDo : scope * ID * list(DataConstructor) * list((scope * Expr)) * (ID * (scope * Expr)) * list((scope * Expr)) -> (scope * Expr)
  brhDo(s, n, [Constructor(c, ce) | cs], [p, a | as], (c, ve), ar) = brhDo2(s, n, ce, a, betaReduceHead(ve, []), ar).
  brhDo(s, n, [Constructor(_, ce) | cs], [p, _ | as], (c, ve), ar) = brhDo(s, n, cs, [p | as], (c, ve), ar).
  
  // APPLIES ARGUMENTS TO FUNCTION
  // Given a
  // - Data type name
  // - Constructor definition expression
  // - Function .. -> .. -> p (constructor) that was given to the eliminator for constructor
  // - Value that is elimininated, original value
  // - List of arguments to the original function, for recursive applications
  // Returns beta reduced value
  brhDo2 : scope * ID * Expr * (scope * Expr) * (scope * Expr) * list((scope * Expr)) -> (scope * Expr)
  brhDo2(s, n, Var(n), f, (vs, Var(_)), _) = f.
  brhDo2(s, n, FnType(_, Var(n), c), f, (vs, FnDestruct(vf, va)), ar) = brhDo2(s, n, c, kApply(kApply(f, (vs, va)), r), betaReduceHead((vs, vf), []), ar) :-
  	r == betaReduceHead((s, DataElim(n)), append(ar, (vs, va))).
  brhDo2(s, n, FnType(_, _, c), f, (vs, FnDestruct(vf, va)), ar) = brhDo2(s, n, c, kApply(f, (vs, va)), betaReduceHead((vs, vf), []), ar).
  
  // Get the `v` argument and everything after that, given constructors and arguments
  brhDoGetAVR : list(DataConstructor) * list((scope * Expr)) -> (list((scope * Expr)) * (ID * (scope * Expr)) * list((scope * Expr)))
  brhDoGetAVR([], [_, v | as]) = ([], (brhDoGetV2(betaReduceHead(v, [])), v), as).
  brhDoGetAVR([_|cs], [a|as]) = ([a | ra], rv, rr) :- (ra, rv, rr) == brhDoGetAVR(cs, as).
  
  // Get the `v` argument from the `v` argument applied to things
  brhDoGetV2 : (scope * Expr) -> ID
  brhDoGetV2((s, FnDestruct(f, a))) = brhDoGetV2(betaReduceHead((s, f), [])).
  brhDoGetV2((s, Var(n))) = n.
  
  append : list((scope * Expr)) * (scope * Expr) -> list((scope * Expr))
  append([], x) = [x].
  append([e | es], x) = [e | append(es, x)].
  

  betaReduce_((s, e@DataType(_, _))) = e.
  expectBetaEq_((_, DataType(n, _)), (_, DataType(n, _))).
  
  
  
  