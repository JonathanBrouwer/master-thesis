\chapter{A comparison with implementations in logical frameworks}
\label{ch:comp-lambdapi}

There exist several \emph{logical frameworks}, tools designed specifically for implementing and experimenting with dependent type theories, such as ALF~\cite{MagnussonN93}, Twelf~\cite{PfenningS99}, Dedukti~\cite{BoespflugCH12}, Elf~\cite{pfenning_1991} and Andromeda~\cite{BauerHP20}. Since these tools are designed specifically for the task, implementing the type system takes less effort in them compared to Spoofax, but for other tasks such as defining a parser or editor services they are not as well equipped. 

In this chapter we will be implementing the language defined in chapter \ref{chap:baselang} in lambdapi, a proof assistant based on the $\lambda \Pi$-calculus modulo rewriting~\cite{BoespflugCH12}. 

\section{Defining symbols}

We will define a symbol in the meta language (lambdapi) for each construct in the object language. The result is visible in figure \ref{fig:lp-symbols}. We will leave \verb|Let| out of the language for now, it will be discussed separately in section \ref{ch:comp-lambdapi:let}.

\begin{figure}[ht]
\begin{lstlisting}
constant symbol TmSort : TYPE;
symbol TmType : `Π` (a : TmSort), TYPE;

constant symbol Type : TmSort;

constant symbol FnType :
  `Π` (A : TmSort), 
  `Π` (B : TmType A → TmSort), 
TmSort;

symbol FnConstruct :
  `Π` (A : TmSort), 
  `Π` (B : TmType A → TmSort), 
  `Π` (f : `Π` (x : TmType A), TmType (B x)), 
  TmType (FnType A B);

symbol FnDestruct :
  `Π` (A : TmSort), 
  `Π` (B : TmType A → TmSort), 
  `Π` (f : TmType (FnType A B)),
  `Π` (a : TmType A),
  TmType (B a);
\end{lstlisting}
	\caption{Symbols of the Calculus of Constructions}
\label{fig:lp-symbols}
\end{figure}

First, \verb|TmSort : TYPE| is the meta-language type of a type in the object language. So in any place where we say \verb|A : TmSort|, this means \verb|A| is a type in the object language. Next, \verb|TmType : (a : TmSort) -> TYPE| is the meta-language type of a term of type \verb|a| in the object language. So if we have \verb|x : TmType Bool| then \verb|x| is a boolean in the object language. 

Now we will define a symbol for each construct in the language we are defining.
\begin{enumerate}
	\item \verb|Type| is a type.
	\item \verb|FnType| is a type, but it takes two arguments: \verb|A| is the argument type and \verb|B| is the return type, which is allowed to depend on a value of the argument type.
	\item \verb|FnConstruct| takes three arguments: \verb|A| is the argument type, \verb|B| is the return type (allowed to depend on \verb|A| again), and \verb|f| is a function in the meta language of type \verb|x : A -> B x|.
	\item \verb|FnDestruct| takes four arguments: \verb|A| is the argument type, \verb|B| is the return type (allowed to depend on \verb|A| again), a term of type \verb|A -> B| and an argument of type \verb|A|. 
\end{enumerate}

Note that these types can only represent type-correct terms, \emph{intrinsically typed} terms. This is useful because it means the meta language does the type checking for us. The disadvantage is that it requires extra information: We need to give \verb|B| for \verb|FnConstruct| and \verb|A| and \verb|B| for \verb|FnDestruct|, which is information we don't have to provide to type-check terms in Statix. These could easily be automatically generated by a type checker but are tedious to specify manually. 

It seems like it should be possible to infer these, but lambdapi fails to infer even the simplest ones. \todo{not sure why}.

\section{Reduction rules}

We define reduction rules to reduce the symbols we defined in the previous section into lambdapi. Lambdapi can then evaluate the rules using its own semantics, not requiring any additional rules similar to the ones in figure \ref{fig:beta-head-reduce-rules}. The reduction rules are given in figure \ref{fig:lp-rules}. Each of the constructs is reduced to the corresponding construct in the meta language.

\begin{figure}[ht]
	\begin{lstlisting}
rule TmType Type `$\hookrightarrow$` TmSort;
rule TmType (FnType $A $B) `$\hookrightarrow$` `Π` (x : TmType $A), TmType ($B x);
rule FnConstruct _ _ $f `$\hookrightarrow$` $f;
rule FnDestruct _ _ $f $a `$\hookrightarrow$` $f $a;
	\end{lstlisting}
	\caption{Reduction Rules for the Calculus of Constructions}
	\label{fig:lp-rules}
\end{figure}

\section{\label{ch:comp-lambdapi:let}Defining let bindings}

Let bindings require substitution, which is not possible to encode in lambdapi. We can encode a less powerful version of let bindings, which are not substituted but evaluated via functions. The definition of this is given in figure \ref{fig:lp-let}. The body of the let binding is allowed to depend on a value of type \verb|A|, but it is not aware of the exact value \verb|v| of the let binding. 

\begin{figure}[ht]
	\begin{lstlisting}
symbol Let : 
	`Π` (A : TmSort), 
	`Π` (B : TmType A → TmSort), 
	`Π` (v : TmType A),
	`Π` (b : TmType A → TmType (B v)),
	TmType (B v);
rule Let _ _ $v $b `$\hookrightarrow$` $b $v;
	\end{lstlisting}
	\caption{Definition of less powerful Let in lampdapi}
	\label{fig:lp-let}
\end{figure}

One program which would not type-check with this approach is the following. It fails to compile since it cannot know that \verb|b| is a boolean, which is required by the definition of f. \footnote{Assuming we introduce booleans into the language, there are examples that don't require booleans but they are a bit more difficult to understand}.
\begin{lstlisting}
let T = Bool;
\f: Bool -> Bool;
\b: T. f b
\end{lstlisting}
