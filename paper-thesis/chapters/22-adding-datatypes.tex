\chapter{Inductive Data Types}
\label{ch:datatypes}

\section{Introduction to Inductive Data Types}
\label{ch:datatypes:intro}

Another useful feature is support for inductive data types. An example of a simple inductive datatype is the \verb|Nat| type:
\begin{lstlisting}
data Nat : -> Type where
    zero : Nat,
    suc : Nat -> Nat;
\end{lstlisting}
We will design data types to have the same features as in Agda:
\begin{enumerate}
\item Data types may be recursive, that is the data type may take itself as one of the constructor arguments. This can be seen in the definition of \verb|Nat| above.
\item Parameters, which are datatypes that are polymorphic, and are required to be the same for all constructors, such as
\begin{lstlisting}
data Maybe (T : Type) : -> Type where
    None : Maybe T,
    Some : T -> Maybe T;
\end{lstlisting}
\item Indices, which are datatypes that are polymorphic, that may vary from constructor to constructor
\begin{lstlisting}
data Eq : (e1: Bool) (e2 : Bool) -> Type where
    refl : e : Bool -> Eq e e;
\end{lstlisting}
\item We can also combine parameters and indices, for example to create the generic \verb|Eq| type. Note that parameters and indices may also depend on earlier parameters and indices.
\begin{lstlisting}
data Eq (T : Type) : (e1 : T) (e2 : T) -> Type where
    refl : e : T -> Eq e e;
\end{lstlisting}
\item Data types must be strictly positive. This ensures that we cannot make non-terminating programs\footnote{After we add support for universes in chapter \ref{ch:universes}}. For example, the following data type is forbidden, because it refers to itself in a negative position. We will explain exactly how this check works in section \ref{ch:datatypes:positivity}.
\begin{lstlisting}
data Bad : -> Type where
	bad : (Bad -> Bool) -> Bad;
\end{lstlisting}
\end{enumerate}

A difference between Agda and our implementation is that Agda has case matching as a native construct, whereas we chose to use eliminators~\cite{eliminators}. An eliminator is a function that can be used to case match on a data type. For example, the eliminator of the \verb|Nat| type above is:
\begin{lstlisting}
elim Nat : P: (v: Nat -> Type) -> P Z 
	-> (x: Nat -> P x -> P (S x)) -> n: Nat -> P n
\end{lstlisting}

The general type of an eliminator for a data type \verb|N| is:
\begin{lstlisting}
parameters 
-> P: (indices -> N params indices -> Type) 
-> constructors
-> indices
-> v: N params indices
-> P indices v
\end{lstlisting}
The meaning of all the arguments is:
\begin{itemize}
	\item \verb|parameters| are the parameters of the data type we want to eliminate, since these are constant among all constructors those can be at the start.
	\item \verb|P| is the type that this eliminator will return. It may depend on the value \verb|v| that is eliminated.
	\item \verb|constructors| is a function that eliminates each of the constructors of the datatype. To eliminate a constructor of the form \verb|C : args -> N params indices| it generates a function \verb|args -> P indices (C pars args)|. For recursive datatypes, a previous case is generated, such as the \verb|P x| in the eliminator of \verb|Nat| above.
	\item \verb|indices| are the indices of the value that is to be eliminated.
	\item \verb|v| is the value that is to be eliminated.
	\item Finally, \verb|P indices v| is the result of the elimination.
\end{itemize}

\section{Type-checking data type declarations}
\label{ch:datatypes:typechecking}

The definition of \verb|type_check| for an inductive data type \verb|N| is, conceptually:
\begin{enumerate}
	\item Create a new scope \verb|s1| whose parent is the scope the declaration was in \verb|s0|.
	\item \label{name-decl}Declare \verb|N : Params -> Indices -> Type| in \verb|s1|.
	\item \label{datatype-decl}We use a new scope-graph relation \verb|datatype : ID -> Expr| and declare \\ \verb|N : DataType(name, params, indices, constructors)| in \verb|s1| so that we can access information about the data type later.
	
	\item Create a chain of scopes starting in \verb|s1| that will contain a scope for each parameter. We will type-check each next parameter using the previous parameters scope, so that parameters can depend on previous parameters. Call the end of this chain \verb|s2|.
	
	\item Create a chain of scopes starting in \verb|s2| that will contain a scope for each index. We will type-check each next index using the previous index' scope, so that one index can depend on parameters and previous indices. Call the end of this chain \verb|s3|.
	
	\item Create a new scope \verb|s4| with \verb|s1| as the parent. Then type-check each constructor with \verb|s2| as scope (so that the constructors can depend on parameters, but cannot depend on indices), and declare the type of that constructor in \verb|s4|. The parameters are automatically added to the type of the constructor.
	
	\item Type-check the rest of the program with scope \verb|s4|.
\end{enumerate}
For example, for the following inductive datatype:
\begin{lstlisting}
data Eq (T : Type) : (e1 : T) (e2 : T) -> Type where
	refl : e : T -> Eq e e;
...
\end{lstlisting}
Figure \ref{scope-graph-eq} shows the scope graph generated by this data type.
\begin{figure}[!ht]
	\begin{framed}
		\centering
		\begin{tikzpicture}[scopegraph, node distance = 6.5em and 5em]
			% S0 and S1 node
			\node[scope] (s0) {$s0$};
			\node[scope, below = 2em of s0] (s1) {$s1$};
			\draw (s1) edge[lbl={P}] (s0);

			% S1 declarations
			\node[type, above right=0.5em and 3em of s1, text width=11cm] (ntype) {\texttt{Eq : (T : Type) -> (e1 : T) -> (e2 : T) -> Type)}};
			\draw (ntype) edge[type, lbl={name}] (s1);
			\node[type, below right=0em and 3em of s1, text width=11cm] (ndatatype) {\texttt{Eq : DataType("Eq", [("T", Type())], [("e1", Var("T")), ("e2", Var("T"))], [("refl", ...)])}};
			\draw (ndatatype) edge[type, lbl={datatype}] (s1);
			
			% Path to S3
			\node[scope, below right=4em and 1em of s1] (s2a) {s2};
			\draw (s2a) edge[lbl={P}] (s1);
			\node[type, right=3em of s2a] (ntype) {\texttt{T : Type}};
			\draw (ntype) edge[type, lbl={name}] (s2a);
			
			\node[scope, below=1em of s2a] (s2b) {};
			\draw (s2b) edge[lbl={P}] (s2a);
			\node[type, right=3em of s2b] (ntype) {\texttt{e1 : T}};
			\draw (ntype) edge[type, lbl={name}] (s2b);
			
			\node[scope, below=1em of s2b] (s2c) {s3};
			\draw (s2c) edge[lbl={P}] (s2b);
			\node[type, right=3em of s2c] (ntype) {\texttt{e2 : T}};
			\draw (ntype) edge[type, lbl={name}] (s2c);
			
			% S4
			\node[scope, below = 12em of s1] (s4) {$s4$};
			\draw (s4) edge[lbl={P}] (s1);
			\node[type, right=3em of s4] (ntype) {\texttt{refl : (T : Type) -> (e : T) -> Eq e e}};
			\draw (ntype) edge[type, lbl={name}] (s4);
		\end{tikzpicture}
	\end{framed}
	\caption{The scope graph generated by the Eq data type.}
	\label{scope-graph-eq}
\end{figure}

\section{Type-checking eliminators}

The type of an eliminator was discussed in section \ref{ch:datatypes:intro}. When we type check an \verb|elim N| expression, the following happens:
\begin{enumerate}
	\item Query the scope to find the data type declaration that we created in point \ref{datatype-decl} of section \ref{ch:datatypes:typechecking}. This gives us access to the parameters, indices and constructors of the data type that is being eliminated. 
	\item Using some tedious logic, create the type discussed in section \ref{ch:datatypes:intro}. This ends up being around 100 lines of Statix code.
\end{enumerate}

The second part that needs to be defined is beta reducing an eliminator. During this process, the following happens:
\begin{enumerate}
	\item Query the scope to find the data type declaration that we created in point \ref{datatype-decl} of section \ref{ch:datatypes:typechecking}. This gives us access to the parameters, indices and constructors of the data type that is being eliminated. (Same as during type checking)
	\item Try to split the arguments applied to the eliminator into the groups defined in section \ref{ch:datatypes:intro}. If this fails (because there are not enough arguments), the eliminator cannot be reduced.
	\item Beta head reduce \verb|v|, if this does not result in one of the constructors of the datatype at the head then the eliminator cannot be reduced. 
	\item Apply the relevant function that eliminates the constructor to the arguments of the datatype. Generate recursive calls to the eliminator for recursive datatypes.
\end{enumerate}

\section{Positivity Checking}
\label{ch:datatypes:positivity}
	
When defining a recursive data type, we would like our datatype to be \emph{strictly positive}, meaning that it can only be recursive on positive positions. If this rule would not exist, we would be able to create non-terminating functions using the datatype. Since under the curry-howard correspondence this allows to prove false, this is undesirable.

\begin{lstlisting}
data Bad : Set where
	bad : (Bad -> Bad) -> Bad
	--     A       B       C
	-- A is in a negative position, B and C are OK
\end{lstlisting}

The implementation is simply an extra check during the type checking of data type declarations. It checks that the datatype only refers to itself in positive positions.
