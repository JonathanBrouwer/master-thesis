% !TEX root = document.tex

\chapter{\label{chap:baselang}Base Language}

The base language that was implemented is the Calculus of Constructions \autocite{Coquand_Huet_1988}, with a syntax somewhat similar to that of Haskell. One extra feature was added that is not present in the Calculus of Constructions, that is, let bindings.

\section{Syntax}

The syntax of the base language is defined in SDF3, the syntax definition language of Spoofax. The definition is very similar to that of a simply typed lambda calculus, except that types and expressions are a single sort. 

\begin{lstlisting}
context-free sorts
	Expr
	
context-free syntax
	Expr.Let = [let [ID] = [Expr]; [Expr]]
	Expr.Type = "Type"
	Expr.Var = ID
	Expr.FnType = ID ":" Expr "->" Expr {right}
	Expr.FnConstruct = "\\" ID ":" Expr "." Expr
	Expr.FnDestruct = Expr Expr {left}
	Expr = "(" Expr ")" {bracket}

context-free priorities
	Expr.Type > Expr.Var > Expr.FnType > Expr.FnDestruct 
		> Expr.FnConstruct > Expr.Let
\end{lstlisting}

\section{How scope graphs are used}

To type-check the base language, we need to scope graph, this section describes how scope graphs are used.

The scope graph only has a single type of edge, called \verb|P| (parent) edges. It also only has a single relation, called \verb|name|. This name stores a \verb|NameEntry|, which can be either a \verb|NameType|, which stores the type of a name, or a \verb|NameSubst|, which stores a substitution corresponding to a name. 

\begin{lstlisting}
signature sorts
	NameEntry
constructors
	NameType : Expr -> NameEntry
	NameSubst : scope * Expr -> NameEntry
relations
	name : ID -> NameEntry
name-resolution	labels P
\end{lstlisting}

These are all the definitions we will need to type-check programs. Next, we will introduce some Statix relations that can be used to interact with these scope graphs:

\begin{lstlisting}
scopePutType : scope * ID * Expr -> scope
scopePutSubst : scope * ID * (scope * Expr) -> scope
scopeGetName : scope * ID -> NameEntry
scopeGetNames : scope * ID -> list((path * (ID * NameEntry)))
empty_scope : -> scope
\end{lstlisting}

The \verb|scopePutType| and \verb|scopePutSubsts| relations generate a new scope given a parent scope and a type or substitution respectively. To query the scope graph, use \verb|scopeGetName| or \verb|scopeGetNames|, which will return a \verb|NameEntry| or a list of \verb|NameEntries| respectively that the query found. Finally, \verb|empty_scope| returns a fresh empty scope.

\section{Typechecking programs}

We will define a statix relation \verb|typeOfExpr| that takes a scope and an expression and typechecks the scope in the expression. It returns the type of the expression.

\begin{lstlisting}
typeOfExpr : scope * Expr -> Expr
\end{lstlisting}

\subsection{Typechecking Type, Let bindings and Variables}

The \verb|Type| expression, being the Type of Types, has itself as its Type.

\begin{lstlisting}
typeOfExpr(_, Type()) = Type().
\end{lstlisting}

Let bindings are typechecked by first typechecking the value that was bound, and then putting this as a substitution in the scope graph. This new scope is then used to typecheck the body.

\begin{lstlisting}
typeOfExpr(s, Let(n, v, b)) = typeOfExpr(s', b) :-
	typeOfExpr(s, v) == _,
	scopePutSubst(s, n, (s, v)) == s'.
\end{lstlisting}

We can then typecheck variables by querying the scope graph using \verb|scopeGetName|. Then, we need to define a relation \verb|typeOfNameEntry| that takes the \verb|NameEntry|, if it is a \verb|NameType| returns the type, and if it is a \verb|NameSubst| computes the type of the substitution \footnote{Note that as an optimization, to avoid recomputing the type each time the variable is used, we could compute the type of the NameSubst when we create the NameEntry. To keep the implementation as simple as possible, we didn't do this for now.}. 

\begin{lstlisting}
typeOfExpr(s, Var(id)) = typeOfNameEntry(scopeGetName(s, id)).
typeOfNameEntry : NameEntry -> Expr
typeOfNameEntry(NameType(T)) = T.
typeOfNameEntry(NameSubst(se, e)) = typeOfExpr(se, e).
\end{lstlisting}

\subsection{Beta Reductions}
A unique requirement for dependently typed languages is beta reduction during typechecking, since types may require evaluation to compare.  In this section, we will define three rules, \verb|expectBetaEq|, which compares two expressions and checks if they're equal, \verb|betaReduce|, which fully evaluates an expression, and \verb|betaReduceHead|, which evaluates the head of an expression.

Starting with the latter, the signature of \verb|betaReduceHead| is the following, taking in an expression with a scope, and also returning and expression with a possibly different scope.

\begin{lstlisting}
betaReduceHead : (scope * Expr) -> (scope * Expr)
\end{lstlisting}



\subsection{Typechecking Functions}

Functions consist of three different expressions, \verb|FnType|, the type of functions, \verb|FnConstruct|, the constructor for functions (a lambda function) and \verb|FnDestruct|, the destructor for functions (function application).

 The type of a \verb|FnType| expression is \verb|Type|, however we do need to typecheck the subexpressions. The argument type can be typechecked using the same scope, but because this is a dependently typed language, the return type may contain references to the name of the argument. Thus, we need to add the type of the variable to the scope before typechecking the return type. We then check that both the argument type and the return type are types, by checking that their type is beta equal to \verb|Type|.
 
\begin{lstlisting}
typeOfExpr(s, FnType(arg_name, arg_type, rtrn_type)) = Type() :- {s'}
    expectBetaEq((empty_scope(), typeOfExpr(s, arg_type)), (empty_scope(), Type())),
    scopePutType(s, arg_name, betaReduce((s, arg_type))) == s',
	expectBetaEq((empty_scope(), typeOfExpr(s', rtrn_type)), (empty_scope(), Type())).
\end{lstlisting}

Next, ...



