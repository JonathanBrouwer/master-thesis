module main

imports

  signatures/start-sig
  subst
  beta_eq
  scopes

rules

  programOk : Start
  programOk(Program(expr)) :-
  	typeOfExpr(empty_scope(), expr) == _.
  	
  typeOfExpr : scope * Expr -> Expr
  typeOfExpr(s, e) = T :-
    typeOfExpr_(s, e) == T,
    @e.type := betaReduce(T).
  
  typeOfExpr_ : scope * Expr -> Expr
  typeOfExpr_(_, Type()) = Type().
  
  typeOfExpr_(s, Var(id)) = scopeGetName(s, id).
	
  typeOfExpr_(s, FnType(arg_name, arg_type, rtrn)) = Type() :-
	// The arg type must be a type
  	expectBetaEq(typeOfExpr(s, arg_type), Type()),
  	// Now typecheck the type of the body with the arg in scope
  	expectBetaEq(typeOfExpr(scopePutType(s, arg_name, arg_type), rtrn), Type()).
  	
  typeOfExpr_(s, FnConstruct(arg_name, arg_type, body)) = FnType(arg_name, arg_type, body_type) :-
	// The arg type must be a type
  	expectBetaEq(typeOfExpr(s, arg_type), Type()),
  	// Now typecheck the body with the arg in scope
  	typeOfExpr(scopePutType(s, arg_name, arg_type), body) == body_type.
  
  typeOfExpr_(s, FnDestruct(fn, arg)) = subst(fn_body_type, fn_arg_name, arg) :- {fn_arg_type}
  	// After beta reduction, the type of fn must be FnType
  	betaReduceHead(typeOfExpr(s, fn)) == FnType(fn_arg_name, fn_arg_type, fn_body_type),
  	// And the type of arg must be beta eq to the declared arg type
  	expectBetaEq(typeOfExpr(s, arg), fn_arg_type).
  	
  typeOfExpr_(s, Let(n, v, b)) = typeOfExpr(s, subst(b, n, v)).
 