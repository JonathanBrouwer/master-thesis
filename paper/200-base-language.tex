% !TEX root = document.tex

\chapter{\label{chap:baselang}Base Language}

The base language that was implemented is the Calculus of Constructions \autocite{Coquand_Huet_1988}, with a syntax somewhat similar to that of Haskell. One extra feature was added that is not present in the Calculus of Constructions, that is, let bindings.

\section{Syntax}

The syntax of the base language is defined in SDF3, the syntax definition language of Spoofax. The definition is very similar to that of a simply typed lambda calculus, except that types and expressions are a single sort. 

\begin{lstlisting}
context-free sorts
	Expr
	
context-free syntax
	Expr.Let = [let [ID] = [Expr]; [Expr]]
	Expr.Type = "Type"
	Expr.Var = ID
	Expr.FnType = ID ":" Expr "->" Expr {right}
	Expr.FnConstruct = "\\" ID ":" Expr "." Expr
	Expr.FnDestruct = Expr Expr {left}
	Expr = "(" Expr ")" {bracket}

context-free priorities
	Expr.Type > Expr.Var > Expr.FnType > Expr.FnDestruct 
		> Expr.FnConstruct > Expr.Let
\end{lstlisting}

\section{Static Analysis}


\section{How scope graphs are used}

To type-check the base language, we need to scope graph, this section describes how scope graphs are used.

The scope graph only has a single type of edge, called \verb|P| (parent) edges. It also only has a single relation, called \verb|name|. This name stores a \verb|NameEntry|, which can be either a \verb|NameType|, which stores the type of a name, or a \verb|NameSubst|, which stores a substitution corresponding to a name. 

\begin{lstlisting}
signature sorts
	NameEntry
constructors
	NameType : Expr -> NameEntry
	NameSubst : scope * Expr -> NameEntry
relations
	name : ID -> NameEntry
name-resolution	labels P
\end{lstlisting}

These are all the definitions we will need to type-check programs. Next, we will introduce some Statix relations that can be used to interact with these scope graphs:

\begin{lstlisting}
scopePutType : scope * ID * Expr -> scope
scopePutSubst : scope * ID * (scope * Expr) -> scope
scopeGetName : scope * ID -> (NameEntry * scope)
scopeGetNames : scope * ID -> list((path * (ID * NameEntry)))
empty_scope : -> scopes
\end{lstlisting}

\section{Typechecking programs}

We will define a statix relation \verb|typeOfExpr| that takes a scope and an expression and typechecks the scope in the expression. It returns two expressions, the first being the expression that was input (this will be changed when we add inference), and the second being the type of the input expression.

\begin{lstlisting}
typeOfExpr : scope * Expr -> (Expr * Expr)
\end{lstlisting}

\subsection{Let bindings and variables}

Let bindings are typechecked by first typechecking the value that was bound, and then putting this as a substitution in the scope graph. This new scope is then used to typecheck the body.

\begin{lstlisting}
typeOfExpr_(s, l@Let(n, v, b)) = (Let(n, v', b'), b_type) :- {s'}
	typeOfExpr(s, v) == (v', _),
	scopePutSubst(s, n, (s, v')) == s',
	typeOfExpr(s', b) == (b', b_type).
\end{lstlisting}

We can then 





\section{Garbage}

- Base language is calculus of constructions with lets + type assertions (move type assertions to sec 5?)
- Describe syntax of the base language?
- Describe rules of base language (statix syntax or mathy?)
- Scope graphs for substitutions + scopes