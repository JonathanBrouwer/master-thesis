@article{Coquand_Huet_1988, title={The calculus of constructions}, volume={76}, ISSN={08905401}, url={https://linkinghub.elsevier.com/retrieve/pii/0890540188900053}, DOI={10.1016/0890-5401(88)90005-3}, number={2–3}, journal={Information and Computation}, author={Coquand, Thierry and Huet, Gérard}, year={1988}, month={Feb}, pages={95–120}, language={en} }

@article{patternmatching,
	title = {Eliminating dependent pattern matching without K},
	author = {Jesper Cockx and Dominique Devriese and Frank Piessens},
	year = {2016},
	doi = {10.1017/S0956796816000174},
	url = {http://dx.doi.org/10.1017/S0956796816000174},
	researchr = {https://researchr.org/publication/CockxDP16-0},
	cites = {0},
	citedby = {0},
	journal = {Journal of Functional Programming},
	volume = {26},
}

@inproceedings{idris2,
	title = {Idris 2: Quantitative Type Theory in Practice},
	author = {Edwin C. Brady},
	year = {2021},
	doi = {10.4230/LIPIcs.ECOOP.2021.9},
	url = {https://doi.org/10.4230/LIPIcs.ECOOP.2021.9},
	researchr = {https://researchr.org/publication/Brady21-1},
	cites = {0},
	citedby = {0},
	booktitle = {35th European Conference on Object-Oriented Programming, ECOOP 2021, July 11-17, 2021, Aarhus, Denmark (Virtual Conference)},
	editor = {Anders Møller and Manu Sridharan},
	volume = {194},
	series = {LIPIcs},
	publisher = {Schloss Dagstuhl - Leibniz-Zentrum für Informatik},
	isbn = {978-3-95977-190-0},
}

@article{proofsearch,
	title = {First-order unification by structural recursion},
	author = {Conor McBride},
	year = {2003},
	doi = {10.1017/S0956796803004957},
	url = {http://dx.doi.org/10.1017/S0956796803004957},
	researchr = {https://researchr.org/publication/McBride03},
	cites = {0},
	citedby = {0},
	journal = {Journal of Functional Programming},
	volume = {13},
	number = {6},
	pages = {1061-1075},
}

@mastersthesis{fcpmc,
	title = {Optimising First-Class Pattern Match Compilation},
	author = {Toine Hartman},
	year = {2022},
	month = {2},
	url = {http://resolver.tudelft.nl/uuid:414026ac-b08e-49f3-8aca-1367766161bb},
	researchr = {https://researchr.org/publication/Hartman22-0},
	cites = {0},
	citedby = {0},
	school = {Delft University of Technology},
	type = {Master's thesis},
	advisor = {Jeff Smits},
}

@article{capture_avoiding_sub,
	title = {Call-by-name, call-by-value and the λ-calculus},
	journal = {Theoretical Computer Science},
	volume = {1},
	number = {2},
	pages = {125-159},
	year = {1975},
	issn = {0304-3975},
	doi = {https://doi.org/10.1016/0304-3975(75)90017-1},
	url = {https://www.sciencedirect.com/science/article/pii/0304397575900171},
	author = {G.D. Plotkin},
	abstract = {This paper examines the old question of the relationship between ISWIM and the λ-calculus, using the distinction between call-by-value and call-by-name. It is held that the relationship should be mediated by a standardisation theorem. Since this leads to difficulties, a new λ-calculus is introduced whose standardisation theorem gives a good correspondence with ISWIM as given by the SECD machine, but without the letrec feature. Next a call-by-name variant of ISWIM is introduced which is in an analogous correspondence withthe usual λ-calculus. The relation between call-by-value and call-by-name is then studied by giving simulations of each language by the other and interpretations of each calculus in the other. These are obtained as another application of the continuation technique. Some emphasis is placed throughout on the notion of operational equality (or contextual equality). If terms can be proved equal in a calculus they are operationally equal in the corresponding language. Unfortunately, operational equality is not preserved by either of the simulations.}
}

@inproceedings{clojure,
	author = {Hickey, Rich},
	title = {The Clojure Programming Language},
	year = {2008},
	isbn = {9781605582702},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/1408681.1408682},
	doi = {10.1145/1408681.1408682},
	abstract = {Customers and stakeholders have substantial investments in, and are comfortable with the performance, security and stability of, industry-standard platforms like the JVM and CLR. While Java and C# developers on those platforms may envy the succinctness, flexibility and productivity of dynamic languages, they have concerns about running on customer-approved infrastructure, access to their existing code base and libraries, and performance. In addition, they face ongoing problems dealing with concurrency using native threads and locking. Clojure is an effort in pragmatic dynamic language design in this context. It endeavors to be a general-purpose language suitable in those areas where Java is suitable. It reflects the reality that, for the concurrent programming future, pervasive, unmoderated mutation simply has to go. Clojure meets its goals by: embracing an industry-standard, open platform - the JVM; modernizing a venerable language - Lisp; fostering functional programming with immutable persistent data structures; and providing built-in concurrency support via software transactional memory and asynchronous agents. The result is robust, practical, and fast. This talk will focus on the motivations, mechanisms and experiences of the implementation of Clojure.},
	booktitle = {Proceedings of the 2008 Symposium on Dynamic Languages},
	articleno = {1},
	numpages = {1},
	location = {Paphos, Cyprus},
	series = {DLS '08}
}

@book{tapl,
	abstract = {{A type system is a syntactic method for automatically checking the absence of certain erroneous behaviors by classifying program phrases according to the kinds of values they compute. The study of type systems--and of programming languages from a type-theoretic perspective -- -has important applications in software engineering, language design, high-performance compilers, and security. This text provides a comprehensive introduction both to type systems in computer science and to the basic theory of programming languages. The approach is pragmatic and operational; each new concept is motivated by programming examples and the more theoretical sections are driven by the needs of implementations. Each chapter is accompanied by numerous exercises and solutions, as well as a running implementation, available via the Web. Dependencies between chapters are explicitly identified, allowing readers to choose a variety of paths through the material. The core topics include the untyped lambda-calculus, simple type systems, type reconstruction, universal and existential polymorphism, subtyping, bounded quantification, recursive types, kinds, and type operators. Extended case studies develop a variety of approaches to modeling the features of object-oriented languages.}},
	added-at = {2017-06-29T07:13:07.000+0200},
	author = {Pierce, Benjamin C.},
	biburl = {https://www.bibsonomy.org/bibtex/2078fb5cb1e3638d53ec8aa21e241c306/gdmcbain},
	citeulike-article-id = {105547},
	citeulike-attachment-1 = {pierce_02_types_1110544.pdf; /pdf/user/gdmcbain/article/105547/1110544/pierce_02_types_1110544.pdf; 22f1c7b32c71606a20ff1a75bd784ae57685f7d2},
	citeulike-linkout-0 = {http://ropas.snu.ac.kr/\~{}kwang/520/pierce\_book.pdf},
	citeulike-linkout-1 = {http://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20\&amp;path=ASIN/0262162091},
	citeulike-linkout-10 = {http://www.librarything.com/isbn/0262162091},
	citeulike-linkout-11 = {http://www.worldcat.org/oclc/51958338},
	citeulike-linkout-2 = {http://www.amazon.de/exec/obidos/redirect?tag=citeulike01-21\&amp;path=ASIN/0262162091},
	citeulike-linkout-3 = {http://www.amazon.fr/exec/obidos/redirect?tag=citeulike06-21\&amp;path=ASIN/0262162091},
	citeulike-linkout-4 = {http://www.amazon.jp/exec/obidos/ASIN/0262162091},
	citeulike-linkout-5 = {http://www.amazon.co.uk/exec/obidos/ASIN/0262162091/citeulike00-21},
	citeulike-linkout-6 = {http://www.amazon.com/exec/obidos/redirect?tag=citeulike07-20\&path=ASIN/0262162091},
	citeulike-linkout-7 = {http://www.worldcat.org/isbn/0262162091},
	citeulike-linkout-8 = {http://books.google.com/books?vid=ISBN0262162091},
	citeulike-linkout-9 = {http://www.amazon.com/gp/search?keywords=0262162091\&index=books\&linkCode=qs},
	comment = {recommended by Tony Morris, NICTA, 2015-09-16
	---=note-separator=---
	Recommended as second text by 'type-theory/learn-tt':https://github.com/type-theory/learn-tt},
	day = 01,
	edition = 1,
	file = {pierce_02_types_1110544.pdf},
	howpublished = {Hardcover},
	interhash = {4d6e4bcf471203882efcef73f6463035},
	intrahash = {078fb5cb1e3638d53ec8aa21e241c306},
	isbn = {0262162091},
	keywords = {03b15-higher-order-logic-type-theory},
	month = feb,
	posted-at = {2015-09-16 07:18:50},
	priority = {5},
	publisher = {MIT Press},
	timestamp = {2017-06-29T07:13:07.000+0200},
	title = {{Types and Programming Languages}},
	year = 2002
}

@article{bidirectional,
	author = {Dunfield, Jana and Krishnaswami, Neel},
	title = {Bidirectional Typing},
	year = {2021},
	issue_date = {June 2022},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {54},
	number = {5},
	issn = {0360-0300},
	url = {https://doi.org/10.1145/3450952},
	doi = {10.1145/3450952},
	abstract = {Bidirectional typing combines two modes of typing: type checking, which checks that a program satisfies a known type, and type synthesis, which determines a type from the program. Using checking enables bidirectional typing to support features for which inference is undecidable; using synthesis enables bidirectional typing to avoid the large annotation burden of explicitly typed languages. In addition, bidirectional typing improves error locality. We highlight the design principles that underlie bidirectional type systems, survey the development of bidirectional typing from the prehistoric period before Pierce and Turner's local type inference to the present day, and provide guidance for future investigations.},
	journal = {ACM Comput. Surv.},
	month = {may},
	articleno = {98},
	numpages = {38},
	keywords = {Type checking, type inference}
}

@article{scopes_as_types, title={Scopes as types}, volume={2}, DOI={10.1145/3276484}, number={OOPSLA}, journal={Proceedings of the ACM on Programming Languages}, author={van Antwerpen, Hendrik and Bach Poulsen, Casper and Rouvoet, Arjen and Visser, Eelco}, year={2018}, pages={1–30}} 

@article{spoofax,
	author = {Kats, Lennart and Visser, Eelco},
	year = {2010},
	month = {10},
	pages = {237-238},
	title = {The Spoofax language workbench},
	volume = {45},
	isbn = {978-1-4503-0240-1},
	journal = {ACM SIGPLAN Notices},
	doi = {10.1145/1869542.1869592}
}

@article{krivine,
	author = {Krivine, Jean-Louis},
	title = {A Call-by-Name Lambda-Calculus Machine},
	year = {2007},
	issue_date = {September 2007},
	publisher = {Kluwer Academic Publishers},
	address = {USA},
	volume = {20},
	number = {3},
	issn = {1388-3690},
	doi = {10.1007/s10990-007-9018-9},
	abstract = {We present a particularly simple lazy lambda-calculus machine, which was introduced twenty-five years ago. It has been, since, used and implemented by several authors, but remained unpublished. We also build an extension, with a control instruction and continuations. This machine was conceived in order to execute programs obtained from mathematical proofs, by means of the Curry-Howard (also known as "proof-program") correspondence. The control instruction corresponds to the axiom of excluded middle.},
	journal = {Higher Order Symbol. Comput.},
	month = {sep},
	pages = {199–207},
	numpages = {9},
	keywords = {Curry-Howard correspondence, Lambda-calculus machine, Control instruction}
}

@article{lambda_cube, title={Introduction to generalized type systems}, volume={1}, DOI={10.1017/S0956796800020025}, number={2}, journal={Journal of Functional Programming}, publisher={Cambridge University Press}, author={Barendregt, Henk}, year={1991}, pages={125–154}}

@misc{pi_forall,
	doi = {10.48550/ARXIV.2207.02129},
	author = {Weirich, Stephanie},
	keywords = {Programming Languages (cs.PL), FOS: Computer and information sciences, FOS: Computer and information sciences, D.3.1; D.3.3; F.3.3},
	title = {Implementing Dependent Types in pi-forall},
	publisher = {arXiv},
	year = {2022},
	copyright = {Creative Commons Attribution 4.0 International}
}

@inproceedings{sdf3,
	author = {de Souza Amorim, Lu\'{\i}s Eduardo and Visser, Eelco},
	title = {Multi-Purpose Syntax Definition with SDF3},
	year = {2020},
	isbn = {978-3-030-58767-3},
	publisher = {Springer-Verlag},
	address = {Berlin, Heidelberg},
	url = {https://doi.org/10.1007/978-3-030-58768-0_1},
	doi = {10.1007/978-3-030-58768-0_1},
	abstract = {SDF3 is a syntax definition formalism that extends plain context-free grammars with features such as constructor declarations, declarative disambiguation rules, character-level grammars, permissive syntax, layout constraints, formatting templates, placeholder syntax, and modular composition. These features support the multi-purpose interpretation of syntax definitions, including derivation of type schemas for abstract syntax tree representations, scannerless generalized parsing of the full class of context-free grammars, error recovery, layout-sensitive parsing, parenthesization and formatting, and syntactic completion. This paper gives a high level overview of SDF3 by means of examples and provides a guide to the literature for further details.},
	booktitle = {Software Engineering and Formal Methods: 18th International Conference, SEFM 2020, Amsterdam, The Netherlands, September 14–18, 2020, Proceedings},
	pages = {1–23},
	numpages = {23},
	keywords = {Parsing, Syntax definition, Programming language},
	location = {Amsterdam, The Netherlands}
}



@article{codecompletion,
	author = {Pelsmaeker, Daniel A. A. and van Antwerpen, Hendrik and Poulsen, Casper Bach and Visser, Eelco},
	title = {Language-Parametric Static Semantic Code Completion},
	year = {2022},
	issue_date = {April 2022},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {6},
	number = {OOPSLA1},
	url = {https://doi.org/10.1145/3527329},
	doi = {10.1145/3527329},
	abstract = {Code completion is an editor service in IDEs that proposes code fragments for the user to insert at the caret position in their code. Code completion should be sound and complete. It should be sound, such that it only proposes fragments that do not violate the syntactic and static semantic rules of the language. It should be complete, such that it proposes all valid fragments so that code completion can be used to construct all programs. To realize soundness and completeness, code completion should be informed by the language definition. In practice, the implementation of code completion is an additional effort in the implementation of a language. In this paper, we develop a framework for language-parametric semantic code completion for statically typed programming languages based on their specification of syntax and static semantics, realizing the implementation of a code completion editor service with minimal additional effort. The framework builds on the SDF3 syntax definition formalism and the Statix static semantics specification language. The algorithm reinterprets the static semantics definition to find sound expansions of predicates and solutions to name resolution queries in scope graphs. This allows a search strategy to explore the solution space and synthesize completion proposals. The implementation of the strategy language and code completion algorithm extend the implementation of the Statix solver, and can be used for any language defined in Statix. We demonstrate soundness and completeness of the completion proposal synthesis, and evaluate its performance.},
	journal = {Proceedings of the ACM on Programming Languages},
	month = {apr},
	articleno = {85},
	numpages = {30},
	keywords = {semantic code completion, reference resolution, constraint solving, semantics, name binding, code completion, editor services}
}

@inproceedings{scope_graphs,
	title = {A Theory of Name Resolution},
	author = {Pierre Néron and Andrew P. Tolmach and Eelco Visser and Guido Wachsmuth},
	year = {2015},
	doi = {10.1007/978-3-662-46669-8_9},
	researchr = {https://researchr.org/publication/NeronTVW15},
	cites = {0},
	citedby = {0},
	pages = {205-231},
	booktitle = {Programming Languages and Systems - 24th European Symposium on Programming, ESOP 2015, Held as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2015, London, UK, April 11-18, 2015. Proceedings},
	editor = {Jan Vitek},
	volume = {9032},
	series = {Lecture Notes in Computer Science},
	publisher = {Springer},
	isbn = {978-3-662-46668-1},
}

@inproceedings{MagnussonN93,
	title = {The ALF Proof Editor and Its Proof Engine},
	author = {Lena Magnusson and Bengt Nordström},
	year = {1993},
	researchr = {https://researchr.org/publication/MagnussonN93},
	cites = {0},
	citedby = {0},
	pages = {213-237},
	booktitle = {Types for Proofs and Programs, International Workshop TYPES 93, Nijmegen, The Netherlands, May 24-28, 1993, Selected Papers},
	editor = {Henk Barendregt and Tobias Nipkow},
	volume = {806},
	series = {Lecture Notes in Computer Science},
	publisher = {Springer},
	isbn = {3-540-58085-9},
	doi = {10.1007/3-540-58085-9_78},
	
}

@inproceedings{PfenningS99,
	title = {System Description: Twelf - A Meta-Logical Framework for Deductive Systems},
	author = {Frank Pfenning and Carsten Schürmann},
	year = {1999},
	url = {http://link.springer.de/link/service/series/0558/bibs/1632/16320202.htm},
	tags = {meta-model, Meta-Environment, meta-objects},
	researchr = {https://researchr.org/publication/PfenningS99},
	cites = {0},
	citedby = {0},
	pages = {202-206},
	booktitle = {Automated Deduction - CADE-16, 16th International Conference on Automated Deduction, Trento, Italy, July 7-10, 1999, Proceedings},
	volume = {1632},
	series = {Lecture Notes in Computer Science},
	publisher = {Springer},
	isbn = {3-540-66222-7},
}

@inproceedings{BoespflugCH12,
	title = {The LM-calculus Modulo as a Universal Proof Language},
	author = {Mathieu Boespflug and Quentin Carbonneaux and Olivier Hermant},
	year = {2012},
	url = {http://ceur-ws.org/Vol-878/paper2.pdf},
	researchr = {https://researchr.org/publication/BoespflugCH12},
	cites = {0},
	citedby = {0},
	pages = {28-43},
	booktitle = {Proceedings of the Second International Workshop on Proof Exchange for Theorem Proving, PxTP 2012, Manchester, UK, June 30, 2012},
	editor = {David Pichardie and Tjark Weber},
	volume = {878},
	series = {CEUR Workshop Proceedings},
	publisher = {CEUR-WS.org},
}

@inproceedings{BauerHP20,
	title = {Equality Checking for General Type Theories in Andromeda 2},
	author = {Andrej Bauer and Philipp G. Haselwarter and Anja Petkovic},
	year = {2020},
	doi = {10.1007/978-3-030-52200-1_25},
	researchr = {https://researchr.org/publication/BauerHP20},
	cites = {0},
	citedby = {0},
	pages = {253-259},
	booktitle = {Mathematical Software - ICMS 2020 - 7th International Conference, Braunschweig, Germany, July 13-16, 2020, Proceedings},
	editor = {Anna Maria Bigatti and Jacques Carette and James H. Davenport and Michael Joswig and Timo de Wolff},
	volume = {12097},
	series = {Lecture Notes in Computer Science},
	publisher = {Springer},
	isbn = {978-3-030-52200-1},
}

@inproceedings{Miller89,
	title = {A Logic Programming Language with Lambda-Abstraction, Function Variables, and Simple Unification},
	author = {Dale Miller},
	year = {1989},
	tags = {programming languages, logic programming, programming, logic, abstraction},
	researchr = {https://researchr.org/publication/Miller89},
	cites = {0},
	citedby = {0},
	pages = {253-281},
	booktitle = {Extensions of Logic Programming, International Workshop, Tübingen, FRG, December 8-10, 1989, Proceedings},
	editor = {Peter Schroeder-Heister},
	volume = {475},
	series = {Lecture Notes in Computer Science},
	publisher = {Springer},
	isbn = {3-540-53590-X},
	doi = {10.1007/BFb0038698},
}

@inbook{pfenning_1991, place={Cambridge}, title={Logic programming in the LF logical framework}, DOI={10.1017/CBO9780511569807.008}, booktitle={Logical Frameworks}, publisher={Cambridge University Press}, author={Pfenning, Frank}, year={1991}, pages={149–182}}

@article{aterm,
	author = {Jong, H. and Olivier, P. and Stichting, Copyright and Centrum, Mathematisch and Klint, Paul and Olivier, Pieter},
	year = {2000},
	month = {03},
	pages = {},
	title = {Efficient Annotated Terms},
	volume = {30},
	journal = {Software: Practice and Experience},
	doi = {10.1002/(SICI)1097-024X(200003)30:3<259::AID-SPE298>3.0.CO;2-Y}
}

@article{stratego,
	title = {Stratego/XT 0.17. A language and toolset for program transformation},
	journal = {Science of Computer Programming},
	volume = {72},
	number = {1},
	pages = {52-70},
	year = {2008},
	note = {Special Issue on Second issue of experimental software and toolkits (EST)},
	issn = {0167-6423},
	doi = {https://doi.org/10.1016/j.scico.2007.11.003},
	url = {https://www.sciencedirect.com/science/article/pii/S0167642308000452},
	author = {Martin Bravenboer and Karl Trygve Kalleberg and Rob Vermaas and Eelco Visser},
	keywords = {Stratego, Stratego/XT, Program transformation, Rewriting strategies, Rewrite rules, Concrete syntax, Dynamic rewrite rules},
	abstract = {Stratego/XT is a language and toolset for program transformation. The Stratego language provides rewrite rules for expressing basic transformations, programmable rewriting strategies for controlling the application of rules, concrete syntax for expressing the patterns of rules in the syntax of the object language, and dynamic rewrite rules for expressing context-sensitive transformations, thus supporting the development of transformation components at a high level of abstraction. The XT toolset offers a collection of flexible, reusable transformation components, and tools for generating such components from declarative specifications. Complete program transformation systems are composed from these components. This paper gives an overview of Stratego/XT 0.17, including a description of the Stratego language and XT transformation tools; a discussion of the implementation techniques and software engineering process; and a description of applications built with Stratego/XT.}
}

@misc{generictermdestr,
	title={10. Type Unifying Strategies},
	howpublished = {\url{http://www.metaborg.org/en/latest/source/langdev/meta/lang/stratego/strategoxt/10-type-unifying-strategies.html#generic-term-deconstruction}},
	note = {Accessed: 13 Jan 2023}
}

@techreport{sdf3_parser,
	title = {Scannerless Generalized-{LR} Parsing},
	author = {Eelco Visser},
	year = {1997},
	month = {July},
	tags = {parsing algorithm, GLR parsing, rule-based, SDF, lexical syntax, disambiguation, GLR, analysis, rules, context-aware, parsing, scannerless parsing, systematic-approach, ASF+SDF, SGLR, grammar},
	researchr = {https://researchr.org/publication/Visser97-SGLR},
	cites = {0},
	citedby = {6},
	institution = {Programming Research Group, University of Amsterdam},
	number = {P9707},
}

@phdthesis{typeinference,
	title = {Type inference, Haskell and dependent types},
	author = {Adam Michael Gundry},
	year = {2013},
	url = {http://ethos.bl.uk/OrderDetails.do?uin=uk.bl.ethos.605927},
	note = {British Library, EThOS},
	researchr = {https://researchr.org/publication/ethos-1465},
	cites = {0},
	citedby = {0},
	school = {University of Strathclyde, Glasgow, UK},
}

@misc{expression_problem, title={https://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt}, url={https://homepages.inf.ed.ac.uk/}, journal={The University Of Edinburgh Homepages}, author={Wadler, Philip}, year={1998}, month={Nov}} 

@misc{core_coq,
title={Core Language of Coq},
url={https://coq.inria.fr/refman/language/core/index.html},
author={Inria, CNRS and contributors},
}
@InProceedings{lean,
	author="de Moura, Leonardo
	and Kong, Soonho
	and Avigad, Jeremy
	and van Doorn, Floris
	and von Raumer, Jakob",
	editor="Felty, Amy P.
	and Middeldorp, Aart",
	title="The Lean Theorem Prover (System Description)",
	booktitle="Automated Deduction - CADE-25",
	year="2015",
	publisher="Springer International Publishing",
	address="Cham",
	pages="378--388",
	abstract="Lean is a new open source theorem prover being developed at Microsoft Research and Carnegie Mellon University, with a small trusted kernel based on dependent type theory. It aims to bridge the gap between interactive and automated theorem proving, by situating automated tools and methods in a framework that supports user interaction and the construction of fully specified axiomatic proofs. Lean is an ongoing and long-term effort, but it already provides many useful components, integrated development environments, and a rich API which can be used to embed it into other systems. It is currently being used to formalize category theory, homotopy type theory, and abstract algebra. We describe the project goals, system architecture, and main features, and we discuss applications and continuing work.",
	isbn="978-3-319-21401-6"
}



@mastersthesis{Zwaan21,
	title = {Composable Type System Specification using Heterogeneous Scope Graphs},
	author = {Zwaan, Aron},
	year = {2021},
	month = {January},
	url = {http://resolver.tudelft.nl/uuid:68b7291c-0f81-4a70-89bb-37624f8615bd},
	school = {Delft University of Technology}
}

@misc{chc, howpublished={\url{https://www.cs.cornell.edu/courses/cs3110/2021sp/textbook/adv/curry-howard.html}}, title={Curry-Howard correspondence}, year ={2021}, month=jun} 

@article{eliminators,
	author = {Dybjer, Peter},
	year = {1994},
	month = {01},
	pages = {440-465},
	title = {Inductive families},
	volume = {6},
	journal = {Formal Aspects of Computing},
	doi = {10.1007/BF01211308}
}

@misc{semcomplet,
	title = {How to enable semantic code completion - Spoofax 3},
	author = {Metaborg},
	howpublished = {\url{https://spoofax.dev/spoofax-pie/develop/guide/static-semantics/code-completion/}},
	note = {Accessed: 2023-01-27}
	
}

@inproceedings{nameres,
	title = {A Theory of Name Resolution},
	author = {Pierre Néron and Andrew P. Tolmach and Eelco Visser and Guido Wachsmuth},
	year = {2015},
	doi = {10.1007/978-3-662-46669-8_9},
	url = {http://dx.doi.org/10.1007/978-3-662-46669-8_9},
	researchr = {https://researchr.org/publication/NeronTVW15},
	cites = {0},
	citedby = {0},
	pages = {205-231},
	booktitle = {Programming Languages and Systems - 24th European Symposium on Programming, ESOP 2015, Held as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2015, London, UK, April 11-18, 2015. Proceedings},
	editor = {Jan Vitek},
	volume = {9032},
	series = {Lecture Notes in Computer Science},
	publisher = {Springer},
	isbn = {978-3-662-46668-1},
}



@phdthesis{Rouvoet21,
	title = {Correct by Construction Language Implementations},
	author = {Arjen Rouvoet},
	year = {2021},
	researchr = {https://researchr.org/publication/Rouvoet21},
	cites = {0},
	citedby = {0},
	school = {Delft University of Technology},
}

@misc{agda,
    title = {Agda documentation},
    author = {Agda},
    year = {2023},
    howpublished = {\url{https://agda.readthedocs.io/en/v2.6.3/}}
}

@misc{coq,
	title = {Coq documentation},
	author = {Coq},
	year = {2023},
	howpublished = {\url{https://coq.inria.fr/refman/index.html}}
}

@inproceedings{Siekmann86,
	title = {Unification Theory},
	author = {Jörg H. Siekmann},
	year = {1986},
	researchr = {https://researchr.org/publication/Siekmann86},
	cites = {0},
	citedby = {0},
	pages = {365-400},
	booktitle = {ECAI},
}

@book{girard,
	title={Interpr{\'e}tation fonctionnelle et {\'e}limination des coupures de l'arithm{\'e}tique d'ordre sup{\'e}rieur},
	author={Girard, J.Y.},
	url={https://books.google.nl/books?id=IRcVHAAACAAJ},
	year={1972},
}
