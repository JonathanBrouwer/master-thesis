% !TEX root = document.tex

\chapter{\label{chap:baselang}Base Language}

The base language that was implemented is the Calculus of Constructions \autocite{Coquand_Huet_1988}, with a syntax somewhat similar to that of Haskell. One extra feature was added that is not present in the Calculus of Constructions, that is, let bindings.

\section{Syntax}

The syntax of the base language is defined in SDF3, the syntax definition language of Spoofax. The definition is very similar to that of a simply typed lambda calculus, except that types and expressions are a single sort. 

\begin{lstlisting}
context-free sorts
	Expr
	
context-free syntax
	Expr.Let = [let [ID] = [Expr]; [Expr]]
	Expr.Type = "Type"
	Expr.Var = ID
	Expr.FnType = ID ":" Expr "->" Expr {right}
	Expr.FnConstruct = "\\" ID ":" Expr "." Expr
	Expr.FnDestruct = Expr Expr {left}
	Expr = "(" Expr ")" {bracket}

context-free priorities
	Expr.Type > Expr.Var > Expr.FnType > Expr.FnDestruct 
		> Expr.FnConstruct > Expr.Let
\end{lstlisting}

\section{How scope graphs are used}

To type-check the base language, we need to scope graph, this section describes how scope graphs are used.

The scope graph only has a single type of edge, called \verb|P| (parent) edges. It also only has a single relation, called \verb|name|. This name stores a \verb|NameEntry|, which can be either a \verb|NameType|, which stores the type of a name, or a \verb|NameSubst|, which stores a substitution corresponding to a name. 

\begin{lstlisting}
signature sorts
	NameEntry
constructors
	NameType : Expr -> NameEntry
	NameSubst : scope * Expr -> NameEntry
relations
	name : ID -> NameEntry
name-resolution	labels P
\end{lstlisting}

These are all the definitions we will need to type-check programs. Next, we will introduce some Statix relations that can be used to interact with these scope graphs:

\begin{lstlisting}
scopePutType : scope * ID * Expr -> scope
scopePutSubst : scope * ID * (scope * Expr) -> scope
scopeGetName : scope * ID -> NameEntry
scopeGetNames : scope * ID -> list((path * (ID * NameEntry)))
empty_scope : -> scope
\end{lstlisting}

The \verb|scopePutType| and \verb|scopePutSubsts| relations generate a new scope given a parent scope and a type or substitution respectively. To query the scope graph, use \verb|scopeGetName| or \verb|scopeGetNames|, which will return a \verb|NameEntry| or a list of \verb|NameEntries| respectively that the query found. Finally, \verb|empty_scope| returns a fresh empty scope.

\section{Typechecking programs}

We will define a statix relation \verb|typeOfExpr| that takes a scope and an expression and typechecks the scope in the expression. It returns the type of the expression.

\begin{lstlisting}
typeOfExpr : scope * Expr -> Expr
\end{lstlisting}

\subsection{Beta Reductions}
A unique requirement for dependently typed languages is beta reduction during typechecking, since types may require evaluation to compare.  In this section, we will define three rules, \verb|expectBetaEq|, which compares two expressions and checks if they're equal, \verb|betaReduce|, which fully evaluates an expression, and \verb|betaReduceHead|, which evaluates the head of an expression. The signatures of the relations are the following:

\begin{lstlisting}
betaReduceHead : (scope * Expr) -> (scope * Expr)

betaReduce : (scope * Expr) -> Expr
betaReduce(e) = betaReduce_(betaReduceHead(e)).
betaReduce_ : (scope * Expr) -> Expr

expectBetaEq : (scope * Expr) * (scope * Expr)
expectBetaEq(e1, e2) :- expectBetaEq_(betaReduceHead(e1), betaReduceHead(e2)).
expectBetaEq_ : (scope * Expr) * (scope * Expr)
\end{lstlisting}

The definition of \verb|betaReduce| is to first beta reduce the head, and then to match on the resulting head. It could be defined separately, but defining it like this prevents a lot of code duplication. Similarly, the definition of \verb|expectBetaEq| is to first beta reduce the head of both expressions, and then compare their heads using the \verb|expectBetaEq_| relation. The relations \verb|betaReduceHead|,  \verb|betaReduce_|, and \verb|expectBetaEq_|  will be defined incrementally as we build up the language over the next few sections.

\subsection{Typechecking Type}

The \verb|Type| expression, being the type of types, has itself as its type.

\begin{lstlisting}
typeOfExpr(_, Type()) = Type().
\end{lstlisting}

Furthermore, \verb|Type| cannot be beta-reduced, and comparing two types is trivial. Because \verb|expectBetaEq| already executed \verb|betaReduceHead| on both sides, the only way for them to be equal is for both to be exactly \verb|Type()|.

\begin{lstlisting}
betaReduceHead((s, Type())) = (s, Type()).
betaReduce_((_, Type())) = Type().
expectBetaEq_((_, Type()), (_, Type())).
\end{lstlisting}

\subsection{Let bindings and Variables}

Let bindings are typechecked by first typechecking the value that was bound, and then putting the value as a substitution in the scope graph. This new scope is then used to typecheck the body.

\begin{lstlisting}
typeOfExpr(s, Let(n, v, b)) = typeOfExpr(s', b) :-
	typeOfExpr(s, v) == _,
	scopePutSubst(s, n, (s, v)) == s'.
\end{lstlisting}

We can then typecheck variables by querying the scope graph using \verb|scopeGetName|. Then, we need to define a relation \verb|typeOfNameEntry| that takes the \verb|NameEntry|, if it is a \verb|NameType| returns the type, and if it is a \verb|NameSubst| computes the type of the substitution \footnote{Note that as an optimization, to avoid recomputing the type each time the variable is used, we could compute the type of the NameSubst when we create the NameEntry. To keep the implementation as simple as possible, we didn't do this.}. 

\begin{lstlisting}
typeOfExpr(s, Var(id)) = typeOfNameEntry(scopeGetName(s, id)).
typeOfNameEntry : NameEntry -> Expr
typeOfNameEntry(NameType(T)) = T.
typeOfNameEntry(NameSubst(se, e)) = typeOfExpr(se, e).
\end{lstlisting}

Next, we need to define beta reduction for let bindings. This is simple, we only need to define the \verb|betaReduceHead| relation on them. The other relations don't need definitions of let bindings, since \verb|betaReduceHead| can never return a let binding. Note that the definition recursively calls \verb|betaReduceHead|, since the body needs to be put into head-normal form as well.

\begin{lstlisting}
betaReduceHead((s, Let(n, v, b))) = betaReduceHead((scopePutSubst(s, n, (s, v)), b)).
\end{lstlisting}

Finally, we need to define beta reduction for variables. This is a bit more complex. We call \verb|scopeGetNames|, which returns a list of scope graph results. If we can find a substitution for the variable, we keep beta reducing the head of this substitution. Otherwise, we return the variable. Since \verb|betaReduceHead| may return a variable, we also need to define the other relations.

\begin{lstlisting}
betaReduceHead((s, e@Var(id))) = betaReduceHeadVar(id, scopeGetNames(s, id)).
betaReduceHeadVar : ID * list((path * (ID * NameEntry))) -> (scope * Expr)
betaReduceHeadVar(_, [(_, (_, NameSubst(sw, w))) | _]) = betaReduceHead((sw, w)).
betaReduceHeadVar(id, _) = (empty_scope(), Var(id)).

betaReduce_((_, Var(n))) = Var(n).
expectBetaEq_((_, Var(n)), (_, Var(n))).
\end{lstlisting}

\subsection{Typechecking Function Types}

Functions consist of three different expressions, \verb|FnType|, the type of functions, \verb|FnConstruct|, the constructor for functions (a lambda function) and \verb|FnDestruct|, the destructor for functions (function application).

 The type of a \verb|FnType| expression is \verb|Type|, however we do need to typecheck the subexpressions. The argument type can be typechecked using the same scope, but because this is a dependently typed language, the return type may contain references to the name of the argument. Thus, we need to add the type of the variable to the scope before typechecking the return type. The argument type needs to be fully beta reduced, since we don't give types a scope.\footnote{Whether giving types a scope has benefits is an opportunity for future research.} We then check that both the argument type and the return type are types, by checking that their type is beta equal to \verb|Type|.
 
\begin{lstlisting}
typeOfExpr(s, FnType(arg_name, arg_type, rtrn_type)) = Type() :- {s'}
    expectBetaEq((empty_scope(), typeOfExpr(s, arg_type)), (empty_scope(), Type())),
    scopePutType(s, arg_name, betaReduce((s, arg_type))) == s',
	expectBetaEq((empty_scope(), typeOfExpr(s', rtrn_type)), (empty_scope(), Type())).
\end{lstlisting}

Beta reduction for function types is defined relatively trivially, as follows

\begin{lstlisting}
betaReduceHead((s, e@FnType(_, _, _))) = (s, e).
betaReduce_((s, FnType(arg_name, arg_type, rtrn))) = 
	FnType(arg_name, betaReduce((s, arg_type)), betaReduce((s, rtrn))).
\end{lstlisting}

Next, we need to define \verb|expectBetaEq_| for function types. This is not trivial, since we need to keep alpha equality into account. For example, the following two types are considered equal (they are both functions that take in a Type, and return a value of that Type\footnote{It is not possible to implement these functions, but expressing their type is still possible}):

\begin{lstlisting}
x: Type -> x
y: Type -> y
\end{lstlisting}

The solution is to introduce a new constructor for expressions, \verb|AlphaEqVars : ID * ID -> Expr|. In the first function type body, we will substitute \verb|x| with \verb|AlphaEqVars(x, y)|, and in the second function type body we do the same for \verb|y|. We then check if the bodies are equal.

\begin{lstlisting}
expectBetaEq_((s1, FnType(arg_name1, arg_type1, body1)), 
              (s2, FnType(arg_name2, arg_type2, body2))) :- {q}
	expectBetaEq((s1, arg_type1), (s2, arg_type2)),
	q == AlphaEqVars(arg_name1, arg_name2),
	expectBetaEq(
		(scopePutSubst(s1, arg_name1, (empty_scope(), q)), body1), 
		(scopePutSubst(s2, arg_name2, (empty_scope(), q)), body2)).
\end{lstlisting}

\subsection{Typechecking Functions}




