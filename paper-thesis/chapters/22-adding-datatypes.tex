\chapter{Inductive Data Types}
\label{ch:datatypes}

Another useful feature is support for inductive data types. An example of a simple inductive datatype is the \verb|Nat| type:
\begin{lstlisting}
data Nat : -> Type where
    zero : Nat,
    suc : Nat -> Nat;
\end{lstlisting}
We will design data types to have the same features as in Agda:
\begin{enumerate}
\item Data types may be recursive, that is the data type may take itself as one of the constructor arguments. This can be seen in the definition of \verb|Nat| above.
\item Parameters, which are datatypes that are polymorphic, and are required to be the same for all constructors, such as
\begin{lstlisting}
data Maybe (T : Type) : -> Type where
    None : Maybe T,
    Some : T -> Maybe T;
\end{lstlisting}
\item Indices, which are datatypes that are polymorphic, that may vary from constructor to constructor
\begin{lstlisting}
data Eq : (e1: Bool) (e2 : Bool) -> Type where
    refl : e : Bool -> Eq e e;
\end{lstlisting}
\item We can also combine parameters and indices, for example to create the generic \verb|Eq| type. Note that parameters and indices may also depend on earlier parameters and indices.
\begin{lstlisting}
data Eq (T : Type) : (e1 : T) (e2 : T) -> Type where
    refl : e : T -> Eq e e;
\end{lstlisting}
\item Data types must be strictly positive. This ensures that we cannot make non-terminating programs\footnote{After we add support for universes in chapter \ref{ch:universes}}. For example, the following data type is forbidden, because it refers to itself in a negative position. We will explain exactly how this check works in section \ref{ch:datatypes:positivity}.
\begin{lstlisting}
data Bad : -> Type where
	bad : (Bad -> Bool) -> Bad;
\end{lstlisting}
\end{enumerate}

A difference between Agda and our implementation is that Agda has case matching as a native construct, whereas we chose to use eliminators \todo{Citation}. An eliminator is a function that can be used to case match on a data type. For example, the eliminator of the \verb|Nat| type above is:
\begin{lstlisting}
elim Nat : P: (v: Nat -> Type) -> P Z 
	-> (x: Nat -> P x -> P (S x)) -> n: Nat -> P n
\end{lstlisting}

The general type of an eliminator for a data type \verb|N| is:
\begin{lstlisting}
parameters 
-> P: (indices -> N params indices -> Type) 
-> constructors
-> indices
-> v: N params indices
-> P indices v
\end{lstlisting}
The meaning of all the arguments is:
\begin{itemize}
	\item \verb|parameters| are the parameters of the data type we want to eliminate, since these are constant among all constructors those can be at the start.
	\item \verb|P| is the type that this eliminator will return. It may depend on the value \verb|v| that is eliminated.
	\item \verb|constructors| is a function that eliminates each of the constructors of the datatype. To eliminate a constructor of the form \verb|C : args -> N params indices| it generates a function \verb|args -> P indices (C pars args)|.
	\item \verb|indices| are the indices of the value that is to be eliminated.
	\item \verb|v| is the value that is to be eliminated.
	\item Finally, \verb|P indices v| is the result of the elimination.
\end{itemize}

\section{Defining inductive data types}





\section{Positivity Checking}
\label{ch:datatypes:positivity}
	
