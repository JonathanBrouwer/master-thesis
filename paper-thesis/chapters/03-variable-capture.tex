% !TEX root = document.tex

\chapter{\label{chap:namecolls}Avoiding Variable Capturing}

TODO Add reference to types and programming languages

The implementation of the base language shown in chapter \ref{chap:baselang} has one big problem, that is name collisions. This section will explore several ways of solving these collisions. An example of such a collision is the following: What is the type of this expression (a polymorphic identity function)?
\begin{lstlisting}
\T : Type. \T : T. T
\end{lstlisting}

The algorithm so far would tell you it is \verb|T : Type -> T : T -> T|. Given the scoping rules of the language, that is equivalent to \verb|T : Type -> x : T -> x|. However, the correct answer would be \verb|T : Type -> x : T -> T|. There is no way of expressing this type without renaming a variable.

\section{In depth: Why does this happen?}

In this section, we will step through the steps that happen during the type checking of the term above, to explain why the incorrect type signature is returned. To find the type, the following is evaluated:

\begin{lstlisting}
typeOfExpr(_, FnConstruct("T", Type(), FnConstruct("T", Var("T"), Var("T"))))
\end{lstlisting}

\noindent
This creates a new node in the scope graph, and then type checks the body with this scope.

\begin{lstlisting}
typeOfExpr(s1, FnConstruct("T", Var("T"), Var("T")))

(T : Type)
   [s1]
\end{lstlisting}
TODO Latex library for scope graphs

\noindent
The same thing happens, the body of the \verb|FnConstruct| is typechecked with a new scope. Note that the T in the type of the second T is ambiguous.

\begin{lstlisting}
typeOfExpr(s2, Var("T"))

(T : Type)      (T : Var("T"))
	[s1]<-----------[s2]
\end{lstlisting}

Finally, we need to find the type of \verb|T|. This finds the lexically closest definition of \verb|T| (the one in s2), which is correct. But the type of \verb|T| is \verb|T|, which does NOT refer to the lexically closest \verb|T|, but instead to the \verb|T| in s1. This situation, in which a type can contain a reference to a variable that is shadowed, is the problem. We need to find a way to make sure that shadowing like this can never happen.

\section{Alternative Solutions}

\subsection{De Bruijn Indices}

Almost all compilers that typecheck dependently typed languages use de Bruijn representation for variables. Using de Bruijn indices in statix is possible, but sacrifices a lot. It would require a transformation on the AST before typechecking. Modifying the AST like this causes problems, because it changes AST nodes. All editor services that rely on \verb|.ref| annotations, such as renaming, can no longer be used. It also loses a lot of the benefits of using Spoofax, since using scope graphs relies on using names.

\subsection{Uniquifying names}

The first solution that was attempted was having a pre-analysis transformation that gives each variable a unique name. This doesn't work for a variety of reasons. The simplest being, it doesn't actually solve the problem. Names can be duplicated during beta reduction of terms, so we still don't have the guarantee that each variable has a unique name. Furthermore, this is a pre-analysis transformation, so similarly to using de Bruijn indices, it breaks editor services such as renaming.

\subsection{Renaming terms dynamically}

Anytime that we introduce a new name in a type, we could check if the name already exists in the environment, and if it does, choose a different unique name. This approach is possible but tedious to implement in Statix. It requires a new relation to traverse through the type and rename. It also increases the time complexity, as constant traversals of the type are needed.


\section{Using scopes to distinguish names}

The solution we found to work best in the end is to change the definition of \verb|ID|. To be precise, at the grammar level we have two sorts, \verb|RID| is a "Raw ID", being just a string. \verb|ID| will have two constructors, one being \verb|Syn|, a syntactical \verb|ID|. The second one is \verb|ScopedName|, it is defined in statix, so there is no syntax for it. It will be generated by \verb|typeOfExpr|.

\begin{lstlisting}
context-free sorts ID
lexical sorts RID
context-free syntax
   ID.Syn = RID
signature constructors
  ScopedName : scope * RID -> ID
\end{lstlisting}

The \verb|ScopedName| constructor has a scope and a raw ID. The scope is used to uniquely identify the name. The main idea is that whenever we encounter a syntactical name, we replace it with a scoped name, so it unambiguous. The scope graph will never have a syntactical name in it. However, when querying the scope graph for a syntactical name, we return the lexically closest name.

\subsection{The example revisited}

In this section, we will step through the steps that happen during the type checking of the term above, with name collisions solved. To find the type, the following is evaluated, note that the names are now wrapped in a \verb|Syn| constructor:

\begin{lstlisting}
typeOfExpr(_, FnConstruct(Syn("T"), Type(),
	FnConstruct(Syn("T"), Var(Syn("T")), Var(Syn("T")))))
\end{lstlisting}

\noindent
The name in the \verb|FnConstruct| is replaced with a scoped name. The scope of the name is the scope that the name is first defined in. We then type check the body with this scope.

\begin{lstlisting}
typeOfExpr(s1, FnConstruct(Syn("T"), Var(Syn("T")), Var(Syn("T"))))

(ScopedName(s1, T) : Type)
	       [s1]
\end{lstlisting}

\noindent
The same thing happens, the body of the \verb|FnConstruct| is typechecked with a new scope. Note that the type of the new \verb|T| now specifies which \verb|T| it means, so it is no longer ambiguous.

\begin{lstlisting}
typeOfExpr(s2, Var(Syn("T")))

(ScopedName(s1, T) : Type)     (ScopedName(s2, T) : Var(ScopedName(s1, T)))
	       [s1]<----------------------------------[s2]
\end{lstlisting}

Finally, we need to find the type of \verb|T|. This finds the lexically closest definition of \verb|T| (the one in s2), as defined earlier. The type of this \verb|T| is \verb|ScopedName(s1, T)|, which explicitly defined which \verb|T| it is. A name can now never shadow another name, since each scope uniquely identifies a name. The final type of the expression is now:

\begin{lstlisting}
FnType(ScopedName(s1, T), Type(),
	FnType(ScopedName(s2, T), Var(ScopedName(s1, T)), Var(ScopedName(s1, T))))
\end{lstlisting}

\section{Improving the readability of types}

Because the expression above, with \verb|ScopedName|s, is not particularly readable, we add a new post-analysis Stratego pass that converts the \verb|ScopedName|s to ticked named. For example, the above would be transformed to:

\begin{lstlisting}
FnType(T, Type(), FnType(T', Var(T)), Var(T)))
\end{lstlisting}
Ticks are added to names where necessary. We do this by following these rules:

\begin{enumerate}
	\item When we encounter a \verb|ScopedName| for the first time, we keep adding ticks to the name until we find a name that has not been used before. 
	\item We define a dynamic rule \verb|Rename :: string -> string| and we store the new name we generated using this rule.
	\item When we encounter a \verb|ScopedName|, use the \verb|Rename| rule to find what the name was transformed to.
\end{enumerate}

