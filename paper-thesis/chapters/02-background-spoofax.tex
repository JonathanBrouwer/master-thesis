% !TEX root = document.tex
\chapter{\label{chap:bg-spoofax}Background: Spoofax}

This chapter will explain the concepts behind the Spoofax Language Workbench. Readers already familiar with Spoofax are recommended to only skim through this chapter.

The Spoofax Language Workbench~\cite{spoofax} is a platform to develop domain-specific and
general-purpose programming languages. Each aspect of the language is defined in one the meta-languages, each with their own purpose. From these specifications Spoofax generates a parser, type checker and other useful tools. The meta-languages that are used in this thesis are discussed in the sections below:

\section{SDF3}

The meta-language SDF3 is used to define the syntax of the language~\cite{sdf3}, which is then parsed using Spoofax's SGLR parser~\cite{sdf3_parser}.

\paragraph{Syntax definitions}
The syntax of a language is defined through rules of the form \verb|A.C = a| with \verb|A| being a \emph{Non-Terminal}, \verb|C| being the name of a constructor and \verb|a| a list of symbols. To remove ambiguity, one can specify a relative priority for each constructor. For example, below is the syntax of a simple language:
\begin{lstlisting}
context-free sorts
	Expr
context-free syntax
	Expr.Add = Expr "+" Expr
	Expr.Mul = Expr "*" Expr
	Expr.X = "x"
context-free priorities
	Expr.X > Expr.Mul > Expr.Add
\end{lstlisting}

\paragraph{ATerm format}
Using the Syntax, Spoofax will generate a parser. This parser takes in a program in textual format, and outputs ATerms. ATerms are a way of encoding an abstract syntax tree~\cite{aterm}. For example, for the program \verb|x + x * x| the following ATerm is produced:
\begin{lstlisting}
Add(X(), Mul(X(), X()))
\end{lstlisting}

\section{Statix}
Now that the syntax has been determined, we move on to the static semantics. Statix is a declarative language for describing the static semantics of a language~\cite{scopes_as_types}. Using these rules, Statix automatically derives a type checker. The rules are based on \emph{equality constraints}. The basic constraints
are equality constraints \verb|t1 == t2| and inequality constraints \verb|t1 != t2| on terms. An equality constraint is states that two terms are equal or can be unified. An inequality constraint states that two terms are not equal. 

The constraints are generated by predicates. A predicate defines a relation on terms and scopes, it is of the form $\mathtt{p(t_1, ..., t_n) :- c_1, ..., c_n}$. Each constraint $c_1...c_n$ is another predicate or an equality constraint. Below is an example that uses these mechanics to check that an expression does not contain any \verb|Muls|. Note that \verb|noMuls| is not defined for the \verb|Mul| constructor, so it will fail if it encounters one.
\begin{lstlisting}
noMuls(Add(e1, e2)) :- noMuls(e1), noMuls(e2).
noMuls(X()).
\end{lstlisting}

Statix also has functional predicates, these define a one-to-one relationship between input terms and the output term. For example below we use this to associate a type with each expression.
\begin{lstlisting}
typeOfExpr(X()) = INT().
typeOfExpr(Add(e1, e2)) = INT() :-
	typeOfExpr(e1) == INT(),
	typeOfExpr(e2) == INT().
\end{lstlisting}

In Statix, the language designer writes down the declarative semantics. The Statix solver decides the order in which constraints are considered, the language designer has no control over that.

\section[Scope graphs]{\label{sec:statix}Scope Graphs\protect\footnote{Note: This section is adapted from "Composable Type System Specification using Heterogeneous Scope Graphs".~\cite[sect. 4.1.2]{Zwaan21}}}

Statix also has scope graphs. Scope graphs are used to represent a programs' name and type information~\cite{scopes_as_types}~\cite{nameres}. A scope graph is a graph that consists of the following components:

\begin{itemize}
	\item \textit{Scopes} represent "a region in a program that behaves uniformly with respect to name resolution". These scopes are modeled as nodes in the graph. Its graph representation is shown in \autoref{fig:graph-notation-scope}.
	\item \textit{Labeled, directed edges} model visibility relations between scopes. For example, $\scopet{1} \scopeedget[\lblt{P}] \scopet{2}$ indicates that the graph contains an edge from \scopet{1} to \scopet{2} with label \lblt{P}. Its graph representation can be seen in \autoref{fig:graph-notation-edge}.
	\item \textit{Declarations} model a datum (a piece of information, like the type of a variable) under a relation symbol in a scope. Its textual notation is $\scopet{1} \typeedget[rel] d$, meaning datum $d$ is declared in scope $\scopet{1}$ under relation \textit{rel}. Its pictorial equivalent is shown in \autoref{fig:graph-notation-data}.
\end{itemize}

\begin{figure}[!h]
	\begin{framed}
		\begin{subfigure}{0.2\linewidth}
			\centering
			\begin{tikzpicture}[scopegraph, node distance = 5em and 3.0em]
				\node[scope] (s1) {$1$};
			\end{tikzpicture}
			\caption{Scope}
			\label{fig:graph-notation-scope}
		\end{subfigure}
		\begin{subfigure}{0.4\linewidth}
			\centering
			\begin{tikzpicture}[scopegraph, node distance = 5em and 3.0em]
				\node[scope] (s1) {$1$};
				\node[scope, right of = s1] (s2) {$2$};
				\draw (s1) edge[lbl={P}] (s2);
			\end{tikzpicture}
			\caption{Edge}
			\label{fig:graph-notation-edge}
		\end{subfigure}
		\begin{subfigure}{0.4\linewidth}
			\centering
			\begin{tikzpicture}[scopegraph, node distance = 5em and 3.0em]
				\node[scope] (s1) {$1$};
				\node[type, right of = s1] (s2) {$\texttt{x : INT()}$};
				\draw (s1) edge[type, lbl={rel}] (s2);
			\end{tikzpicture}
			\caption{Data}
			\label{fig:graph-notation-data}
		\end{subfigure}
	\end{framed}
	\caption{Scope Graph notation}
\end{figure}

Information can be retrieved from scope graphs using \textit{queries}. A query from a scope traverses the scope graph to find datums that match certain conditions. The result of a query is a list of (path, datum) tuples. A query has several parameters:
\begin{itemize}
	\item The relation to query. Only datums declared under this relation will be returned by the query.
	\item Path well-formedness condition: a regular expression of labels that specifies which paths are well-formed. Only datums that are reached through a path whose edge labels are in the language described by the regular expression are included in the query result.
	\item A match predicate, taking a single datum as input. Only datums that satisfy this predicate will be included in the query result. Its default value is \verb|true|, meaning that all datums under the specified relation that satisfy the path well-formedness condition are returned.
\end{itemize}
