\chapter{Related Work}
\label{ch:relatedwork}

In chapter \ref{ch:comp-haskell} and \ref{ch:comp-lambdapi} we already compared our implementation with two different implementations. In this chapter we discuss remaining related work.
TODO TODO TODO

\section{Other languages implemented in Statix}

In this thesis, we implemented a dependently typed language in Statix. In the following work, other languages are implemented in Statix:

\paragraph{Scopes as Types}

The implementation in this paper requires performing substitutions in types immediately, as types don't have a scope. Van Antwerpen et al.~\cite[sect 2.5]{scopes_as_types}~\cite{nameres} present an implementation of System F in Statix that does lazy substitutions, by using scopes as types. It would be interesting to see if this approach could also apply to the Calculus of Constructions, where types can be arbitrary terms. 

\paragraph{Correct by Construction Language Implementations}

Construction Language Implementations~\cite{Rouvoet21} describes how to create a declarative specification of a language in Statix, and then to use a dependently typed language to integrate the specification of well-typing in the representation of the program that is being interpreted or transformed. The work from this thesis and ours could be combined, by using our dependently typed languages to do this verification.

\section{Other dependently typed languages}

We already implemented the calculus of constructions in Haskell (chapter~\ref{ch:comp-haskell}) and LambdaPi (chapter~\ref{ch:comp-lambdapi}), and compared the implementation in Statix with these implementations. 

Below are some dependently typed languages, we discuss what make these languages unique and if these languages could be implemented in Statix: 

\paragraph{Bidirectional Typing}

In chapter~\ref{ch:comp-haskell} we compared the implementation in Statix with an implementation in Haskell. The pi-forall language~\cite{pi_forall} is a language with a similar complexity to the language presented in this paper. In principle, the implementations are very similar. For example, the inference rules of pi-forall are similar to the inference rules presented in figure \ref{fig:type-check-rules} from this paper. The primary difference is that they use a bidirectional type system~\cite{bidirectional}, whereas this paper uses Statix' unification.

\paragraph{Other}